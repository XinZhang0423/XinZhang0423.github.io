<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>PFONC课堂笔记 | 张心の博客</title><meta name="keywords" content="PFONC,Haskell,ECN,笔记"><meta name="author" content="Xin Zhang"><meta name="copyright" content="Xin Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="语言知识： ..de base：基本的… Explicite,implicite,exhaustive, argument参数(函数声明时的参数,型参)， parametre(实参)，parallélisation(并行计算) Filtrer 过滤，motif 模式，类别类似mode，type的含义, idiomatique习惯用语 natif,native天然的，自带的 Odd奇数，Even偶数">
<meta property="og:type" content="article">
<meta property="og:title" content="PFONC课堂笔记">
<meta property="og:url" content="http://example.com/2022/10/16/PFONC-CM/index.html">
<meta property="og:site_name" content="张心の博客">
<meta property="og:description" content="语言知识： ..de base：基本的… Explicite,implicite,exhaustive, argument参数(函数声明时的参数,型参)， parametre(实参)，parallélisation(并行计算) Filtrer 过滤，motif 模式，类别类似mode，type的含义, idiomatique习惯用语 natif,native天然的，自带的 Odd奇数，Even偶数">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/ECN.jpg">
<meta property="article:published_time" content="2022-10-16T20:52:06.000Z">
<meta property="article:modified_time" content="2022-12-16T19:15:05.253Z">
<meta property="article:author" content="Xin Zhang">
<meta property="article:tag" content="PFONC">
<meta property="article:tag" content="Haskell">
<meta property="article:tag" content="ECN">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ECN.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2022/10/16/PFONC-CM/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'PFONC课堂笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-12-16 20:15:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/ECN.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">张心の博客</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">PFONC课堂笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-12-16T19:15:05.253Z" title="Updated 2022-12-16 20:15:05">2022-12-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ECN-EI2-1/">ECN-EI2|1</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ECN-EI2-1/PFONC/">PFONC</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="PFONC课堂笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>语言知识：</p>
<p>..de base：基本的…</p>
<p>Explicite,implicite,exhaustive, argument参数(函数声明时的参数,型参)， parametre(实参)，parallélisation(并行计算)</p>
<p>Filtrer 过滤，motif 模式，类别类似mode，type的含义, idiomatique习惯用语</p>
<p>natif,native天然的，自带的</p>
<p>Odd奇数，Even偶数,</p>
<p>palindromique回文，正着反着都一样的，数学，字母均可以出palindromique常用于出算法题刁难人。。</p>
<p>clôsure 闭包，在python的高级性质中有生成器(Generator), 闭包(closure)，装饰器(Decorator)</p>
<p>en compréhension指列表元组的推导构造法。</p>
<p>alias pour 就是aka，别名的意思</p>
<p>通配符：指可以指代任意内容的符号</p>
<p>自由变量，约束变量：在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>和其他涉及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80">形式语言</a>的学科中，包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91">数理逻辑</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>，<strong>自由变量</strong>是在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E9%81%94%E5%BC%8F">表达式</a>中用于表示一个位置或一些位置的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AC%A6%E5%8F%B7">符号</a>，某些明确的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E4%BB%A3%E6%8D%A2&action=edit&redlink=1">代换</a>可以在其中发生，或某些运算（比如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B8%BD%E5%92%8C">总和</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%87%8F%E5%8C%96">量化</a>）可以在其上发生。这个概念有关于<strong>占位符</strong>（它是以后会被<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%96%87%E5%AD%97%E4%B8%B2&action=edit&redlink=1">文字串</a>所替换），或表示未指定符号的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%80%9A%E9%85%8D%E7%AC%A6">通配符</a>，但更加深入和复杂。变量x成为<strong>约束变量</strong>，当一个变量使用存在或任意描述时，它就成为了一个约束变量。而可以任意取值的成为自由变量。</p>
<p>占位符，通配符</p>
<h2 id="I-Programmation-fonctionnelle"><a href="#I-Programmation-fonctionnelle" class="headerlink" title="I. Programmation fonctionnelle:"></a>I. Programmation fonctionnelle:</h2><h3 id="definition以及几个不清楚的notions-函数式编程是指用数学函数的组合去表达一个算法。例如递归可以用相邻项的关系表示"><a href="#definition以及几个不清楚的notions-函数式编程是指用数学函数的组合去表达一个算法。例如递归可以用相邻项的关系表示" class="headerlink" title="définition以及几个不清楚的notions :函数式编程是指用数学函数的组合去表达一个算法。例如递归可以用相邻项的关系表示"></a>définition以及几个不清楚的notions :函数式编程是指用数学函数的组合去表达一个算法。例如递归可以用相邻项的关系表示</h3><p>![截屏2022-09-20 10.52.37](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 10.52.37.png)</p>
<p>函数编程是一种特殊的<strong>programmation déclarative</strong> ，</p>
<p>概念解析：什么是声明式编程和命令式编程（一种编程范型）：</p>
<ul>
<li><strong>声明式编程</strong>（英语：Declarative programming）或译为声明式编程，是对与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E5%BC%8F%E7%B7%A8%E7%A8%8B">命令式编程</a>不同的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%8C%83%E5%9E%8B">编程范型</a>的一种合称。它们建造计算机程序的结构和元素，表达<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97">计算</a>的逻辑而不用描述它的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B">控制流程</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%AE%A3%E5%91%8A%E5%BC%8F%E7%B7%A8%E7%A8%8B#cite_note-1">1]</a>。</li>
</ul>
<p>声明式编程包括一下几种子编程范式：</p>
<p>![截屏2022-09-20 10.57.59](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 10.57.59.png)</p>
<ul>
<li>引入λ演算的概念，是第一个定义和<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Th%C3%A8se_de_Church">表征递归函数</a>的形式主义：因此，它在可计算性理论中非常重要，就像<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Machine_de_Turing">图灵的机器1</a>和<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Fonction_r%C3%A9cursive">赫布兰德-哥德尔模型一样</a>。此后，它一直作为<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Programmation_fonctionnelle">理论编程语言</a>和<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Assistant_de_preuve">正式计算机辅助演示</a>的<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/M%C3%A9talangage">元语言</a>。lambda演算可以<em>键入</em><a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Lambda-calcul#Le_lambda-calcul_non_typ.C3.A9">也可以不键入</a>。</li>
</ul>
<p>lambda演算与<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Haskell_Curry">Haskell Curry的</a><a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Logique_combinatoire">组合逻辑</a>相关，并在<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Substitution_explicite">显式替换计算</a>中推广。</p>
<ul>
<li><strong>Valeurs de première classe</strong>&#x3D;<strong>头等对象</strong>（英语：First-class object），在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8">计算机科学</a>中，指称支持其他实体通常能获得的所有运算的实体。这些运算典型的包括：在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E6%9C%9F">执行期</a>创造，作为参数传递给其他函数，或存入一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%8A%E6%95%B8">变数</a>等[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E9%A0%AD%E7%AD%89%E7%89%A9%E4%BB%B6#cite_note-1">1]</a>。将一个实体变为头等对象的过程叫做“<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6%E5%8C%96">物件化</a>”（Reification）[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E9%A0%AD%E7%AD%89%E7%89%A9%E4%BB%B6#cite_note-2">2]</a>。</li>
</ul>
<p>这里的函数均为头等对象，应该是指我可以将函数视为变量进行操作，同时我也可以在执行期创造函数。python和haskell都有这个特点</p>
<p>![截屏2022-09-20 11.04.30](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 11.04.30.png)</p>
<ul>
<li><p><strong>évaluation séquentielle</strong>:顺序赋值，不是一下子全部赋值，而是用多少算多少，没有赋值的先后顺序？还是说是指多个参数函数没有赋值先后次序。</p>
</li>
<li><p><strong>effet de bord</strong>：边界影响，中文对应为副作用</p>
</li>
</ul>
<p>![截屏2022-09-20 11.11.48](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 11.11.48.png)</p>
<p>![截屏2022-09-20 11.13.56](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 11.13.56.png)</p>
<p>explicite，implicite：显式的（完全表现在外面），隐式的（存在未知的隐藏起来的部分）</p>
<ul>
<li>Transparence référentielle:参照透明性：相同输入得到相同输出：</li>
</ul>
<p>une même fonction appliquée sur les mêmes arguments renvoie le même résultat</p>
<ul>
<li>Immutabilité:</li>
</ul>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88">面向对象</a>及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">函数编程语言</a>中，<strong>不可变对象</strong>（英语：Immutable object）是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%89%A9%E4%BB%B6_(%E9%9B%BB%E8%85%A6%E7%A7%91%E5%AD%B8)">对象</a>，在被创造之后，它的状态（成员变量、属性等的值）就不可以被改变。至于状态可以被改变的对象，则被称为可变对象（mutable object）。我们改变这个对象其实是创造了一个新的对象。</p>
<p>不可变意味着<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AA%E8%AF%BB&action=edit&redlink=1">只读</a>不写，因此不可变对象天然地具备<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E7%B7%92%E5%AE%89%E5%85%A8">线程安全</a>的特性，即是说如无其它特殊限制的话可以在任何线程上自由调用。此外，相较于可变对象，不可变对象在一些场合下也较合理，易于了解，而且提供较高的安全性</p>
<h2 id="II-Construction-de-base-haskell基本操作逻辑"><a href="#II-Construction-de-base-haskell基本操作逻辑" class="headerlink" title="II. Construction de base: haskell基本操作逻辑"></a>II. Construction de base: haskell基本操作逻辑</h2><h2 id="2-1-Composition-函数复合"><a href="#2-1-Composition-函数复合" class="headerlink" title="2.1 Composition: 函数复合"></a>2.1 Composition: 函数复合</h2><p>函数的几种复合方式，主要分为隐式和显式两种：</p>
<p><strong>Implicite</strong>:是算完的值作为参数代入下一个函数： f (g x) </p>
<p><strong>explicite</strong>:是先对函数进行操作，然后再代入参数：f.g x  <strong>最常用的要熟悉！！！</strong></p>
<p>特殊函数：<strong>id</strong> identité</p>
<h2 id="2-2-Evaluation-conditionelle-条件赋值-用if对赋值情况进行说明，注意和命令型编程范式区分开，haskell里命令型主要是do-block。"><a href="#2-2-Evaluation-conditionelle-条件赋值-用if对赋值情况进行说明，注意和命令型编程范式区分开，haskell里命令型主要是do-block。" class="headerlink" title="2.2 Évaluation conditionelle: 条件赋值 用if对赋值情况进行说明，注意和命令型编程范式区分开，haskell里命令型主要是do block。"></a>2.2 Évaluation conditionelle: 条件赋值 用if对赋值情况进行说明，注意和命令型编程范式区分开，haskell里命令型主要是do block。</h2><p>常见的赋值方式有好几种：</p>
<ol>
<li><p><strong>用if实现条件赋值：</strong></p>
<p>赋值等于不等于：&#x3D;，&#x3D;&#x3D;，&#x2F;&#x3D;</p>
</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f</span> n = <span class="keyword">if</span> n == <span class="number">0</span> <span class="keyword">then</span> <span class="number">1</span> <span class="keyword">else</span> n * f (n-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>这里if是一种expression表达式而不是接命令，要想接命令则需要 do block </p>
<ol start="2">
<li><strong>évaluation gardée</strong> 类似switch case赋值法</li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">signe</span> n</span><br><span class="line">| n&lt;<span class="number">0</span> = -<span class="number">1</span></span><br><span class="line">| n&gt;<span class="number">0</span> = <span class="number">1</span></span><br><span class="line">| otherwise = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>3.**filtrage par motif (pattern matching)**：非常重要‼️是haskell的特殊用法</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--两种写法，常用第一种。用  _代表所有情况，类似写函数表达式</span></span><br><span class="line"><span class="title">f</span> <span class="number">0</span> = <span class="number">1</span></span><br><span class="line"><span class="title">f</span> n = n * f (n-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">f</span> n = <span class="keyword">case</span> n <span class="keyword">of</span></span><br><span class="line">		<span class="number">0</span> -&gt; <span class="number">1</span></span><br><span class="line">		_ -&gt; n * f (n-<span class="number">1</span>) </span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-3-Recursivite-经典递归，在定义时调用自己"><a href="#2-3-Recursivite-经典递归，在定义时调用自己" class="headerlink" title="2.3 Récursivité: 经典递归，在定义时调用自己"></a>2.3 Récursivité: 经典递归，在定义时调用自己</h2><p>堆栈stack,pile:</p>
<p>递归本质就是一种modele de pile，所以所有递归都可以通过构建一个pile来实现，即循环方法。</p>
<p>需要联系，多写几个</p>
<h2 id="2-4-Fonction-Recursive-terminale-尾调用函数与尾递归"><a href="#2-4-Fonction-Recursive-terminale-尾调用函数与尾递归" class="headerlink" title="2.4 Fonction Récursive terminale:尾调用函数与尾递归"></a>2.4 Fonction Récursive terminale:尾调用函数与尾递归</h2><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A8%88%E7%AE%97%E6%A9%9F%E5%AD%B8">计算机学</a>里，tail evaluation&#x3D;terminale<strong>尾调用</strong>是指一个函数里的最后一个动作是返回一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">函数</a>的调用结果的情形，即最后一步新调用的返回值直接被当前函数的返回结果。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%B0%BE%E8%B0%83%E7%94%A8#cite_note-N.C.Zakas_p61-64-1">1]</a>此时，该尾部调用位置被称为<strong>尾位置</strong>。尾调用中有一种重要而特殊的情形叫做<strong>尾递归</strong>。经过适当处理，尾递归形式的函数的运行效率可以被极大地优化。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%B0%BE%E8%B0%83%E7%94%A8#cite_note-N.C.Zakas_p61-64-1">1]</a>尾调用原则上都可以通过简化函数<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a>的结构而获得性能优化（称为“尾调用消除”），但是优化尾调用是否方便可行取决于运行环境对此类优化的支持程度如何。</p>
<p>具体的方法就是增加多个参数来存储每次计算的值，从而将计算结果记录下来返回。</p>
<p>在程序运行时，计算机会为应用程序分配一定的内存空间；应用程序则会自行分配所获得的内存空间，其中一部分被用于记录程序中正在调用的各个函数的运行情况，这就是函数的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%B0%83%E7%94%A8%E6%A0%88">调用栈</a>。常规的函数调用总是会在调用栈最上层添加一个新的堆栈帧（stack frame，也翻译为“栈帧”或简称为“帧”），这个过程被称作“入栈”或“压栈”（意即把新的帧压在栈顶）。当函数的调用层数非常多时，调用栈会消耗不少内存，甚至会撑爆内存空间（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%88%E6%BA%A2%E5%87%BA">栈溢出</a>）[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%B0%BE%E8%B0%83%E7%94%A8#cite_note-N.C.Zakas_p61-64-1">1]</a>，造成程序严重卡顿或意外崩溃。尾调用的调用栈则特别易于优化，从而可减少内存空间的使用，也能提高运行速度。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%B0%BE%E8%B0%83%E7%94%A8#cite_note-N.C.Zakas_p61-64-1">1]</a>其中，对尾递归情形的优化效果最为明显，尤其是递归算法非常复杂的情形。[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E5%B0%BE%E8%B0%83%E7%94%A8#cite_note-N.C.Zakas_p61-64-1">1]</a></p>
<p>一般来说，尾调用消除是可选的，可以用，也可以不用。然而，在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">函数编程语言</a>中，语言标准通常会要求编译器或运行平台实现尾调用消除。这让程序员可以用递归取代<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%A8%8B%E5%BA%8F%E5%BE%AA%E7%8E%AF">循环</a>而不丧失性能。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.经典例子：阶乘和fibonacci</span></span><br><span class="line"><span class="title">factorielle&#x27;</span> <span class="number">0</span> x = x</span><br><span class="line"><span class="title">factorielle&#x27;</span> n x = factorielle (n-<span class="number">1</span>) x*n</span><br><span class="line"><span class="title">factorielle</span> n =factorielle&#x27;  n <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="title">fibonnacci&#x27;</span> <span class="number">0</span> _ x2 = x2</span><br><span class="line"><span class="title">fibonacci&#x27;</span> n x2 x1 = fibonacci (n-<span class="number">1</span>) (x1+x2) x2</span><br><span class="line"><span class="title">fibonacci</span> n = fibonacci n <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="comment">--尾调用的本质逻辑是用n来记录循环的次数，而通过增加参数的方式记录每次循环的结果，从而有：1.中止条件为n为零，即循环次数达到n次，2.递推关系，根据数学关系决定相邻几项就是增加几个参数来记录结果。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--2.Écrire une fonction récursive qui calcule la puissance n^e d’un nombre乘方公式:</span></span><br><span class="line"><span class="title">puissance&#x27;</span> _ <span class="number">0</span> r = r</span><br><span class="line"><span class="title">puissance&#x27;</span> n e r = puissance&#x27; n e-<span class="number">1</span> r*n</span><br><span class="line"></span><br><span class="line"><span class="comment">--利用odd,even 奇偶判断函数对乘方公式进行改进：</span></span><br><span class="line"><span class="title">puissance&#x27;&#x27;</span> n <span class="number">0</span> r = n*r   <span class="comment">--这里的逻辑是用r记录出现的奇数次多乘的项用n来记录计算出的值，本质上是把e拆成e=2^k+b，即r记录b，n记录k。</span></span><br><span class="line"><span class="title">puissance&#x27;&#x27;</span> n e r = <span class="keyword">if</span> odd e <span class="keyword">then</span> puissance&#x27;&#x27; n*n  (e-<span class="number">1</span>)/<span class="number">2</span>  r*n <span class="keyword">else</span> puissance&#x27;&#x27; n*n e/<span class="number">2</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">--对以上两个乘方公式进行复杂度分析：第一个需要执行e次乘法计算，第二个只需要进行log2e次乘法计算，极大提高效率</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--3.hauteur palindromique 题目逻辑是写一个函数计算一个已知数的回文高度，回文高度定义为这个数通过几次颠倒（image miroir镜像）相加操作是回文的</span></span><br><span class="line"></span><br><span class="line"><span class="title">hpal</span> n x = <span class="keyword">if</span> ( r n ) == n <span class="keyword">then</span> x <span class="keyword">else</span> hpal (n + $ r n)  (x + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="title">r&#x27;</span> <span class="number">0</span> x = x</span><br><span class="line"><span class="title">r&#x27;</span> n x = r (n `div` <span class="number">10</span>)  ( x*<span class="number">10</span> + (n `mod` <span class="number">10</span>) )</span><br><span class="line"><span class="title">r</span> n = r&#x27; n <span class="number">0</span></span><br><span class="line"><span class="comment">--这里镜像函数的逻辑strategie是每次将数整除10消去尾数，模10获得尾数与原来的结果✖️10想加</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="2-5-Declarations-locales-局部声明，注意在haskell里面没有变量的概念，因为所有的都是immutable。"><a href="#2-5-Declarations-locales-局部声明，注意在haskell里面没有变量的概念，因为所有的都是immutable。" class="headerlink" title="2.5 Déclarations locales: 局部声明，注意在haskell里面没有变量的概念，因为所有的都是immutable。"></a>2.5 Déclarations locales: 局部声明，注意在haskell里面没有变量的概念，因为所有的都是immutable。</h2><p>经典局部声明是使用let in和 where，可以对值和函数进行局部声明，类似python里闭包的概念clôsure</p>
<p>![截屏2022-09-20 17.04.00](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 17.04.00.png)</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--注意let in的妙用，在后面的学习中往往会出现因为constructeur而隐藏原来值的情况，通常情况下会有一个fromType函数来获取藏在里面的值，例如fromIntegar, fromJust。 在没有的情况下，我们可以用let in调取藏在constructeur里面的隐藏值：</span></span><br><span class="line"><span class="title">let</span>  <span class="type">Just</span> a =  <span class="type">Maybe</span> b <span class="keyword">in</span> <span class="comment">--从而对藏在里面的a进行操作</span></span><br><span class="line"><span class="comment">--或者使用 </span></span><br><span class="line"><span class="title">a</span> = fromJust b</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="III-Types-haskell的数据类型个人认为是最能彰显其语法特点的部分"><a href="#III-Types-haskell的数据类型个人认为是最能彰显其语法特点的部分" class="headerlink" title="III. Types: haskell的数据类型个人认为是最能彰显其语法特点的部分"></a>III. Types: haskell的数据类型个人认为是最能彰显其语法特点的部分</h2><p>haskell数据类型部分分为：</p>
<p>基本数据类型，<strong>代数型数据类型</strong>data |    |，<strong>构造体和模式识别，</strong> (.    ). let   in ,含参类型  maybe <strong>，</strong>元组和结构体** (  )   {.   }，<strong>递归代数类型，列表和树. Vide |.  arbreV. |  ，</strong>列表的推导构造**[.    |.     &lt;-       ]. ，通用类型type générique翻译的不好，理解不够深刻</p>
<h2 id="3-1-type-de-base"><a href="#3-1-type-de-base" class="headerlink" title="3.1 type de base:"></a>3.1 type de base:</h2><p>基本每个语言都有的数据类型：</p>
<p><strong>整型分为有界整型和无界整型</strong>，浮点数，布尔型，字符和字符串，<strong>注意所有类型均大写否则报错</strong>。</p>
<p>![截屏2022-09-20 17.28.17](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 17.28.17.png)</p>
<p><strong>函数的类型由它的domaine域决定</strong>。</p>
<p>haskell 语言是类型推理<strong>inférence de type</strong>的，<strong>类型推论</strong>、<strong>类型推导</strong>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E7%B1%BB%E5%9E%8B%E6%8E%A8%E8%AE%BA#cite_note-1">1]</a>、<strong>类型推断</strong>、或<strong>隐含类型</strong>，是指<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">编程语言</a>中在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E6%9C%9F">编译期</a>自动推导出值的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>的能力，它是一些<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BC%B7%E9%A1%9E%E5%9E%8B">强</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B">静态类型</a>语言的特性。一般而言，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80">函数式编程语言</a>具有此特性。自动推断类型的能力让很多编程任务变得容易，让程序员可以忽略<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型标注</a>的同时仍然允许类型检查。</p>
<p>在大多数的编程语言中，所有值都有一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">类型</a>，它描述特定值的数据种类。在一些语言中，表达式的类型只在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9F%B7%E8%A1%8C%E6%9C%9F">运行时</a>才知道；这些语言被称作<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E7%B1%BB%E5%9E%8B">动态类型</a>语言例如python。而另一些语言中，表达式的类型在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91%E6%97%B6">编译时</a>就知道，这些语言叫做<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%99%E6%80%81%E7%B1%BB%E5%9E%8B">静态类型</a>语言。在静态类型语言中，函数的输入和输出与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F">局部变量</a>的类型一般必须用<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%B1%BB%E5%9E%8B%E6%A0%87%E6%B3%A8">类型标注</a>明确的提供，也就是声明一下是哪个int。</p>
<p>haskell强大之处在于它是静态类型，就是在编译时就知道变量类型（不同于python），同时又不需要用类型标注，因为可以自动推导数据类型（区别于弱静态类型）</p>
<h2 id="3-2-Type-algebrique-代数型数据类型"><a href="#3-2-Type-algebrique-代数型数据类型" class="headerlink" title="3.2 Type algébrique:代数型数据类型"></a>3.2 Type algébrique:代数型数据类型</h2><p>代数型数据类型是指由基本数据类型通过乘法方式或者加法方式组成的更复杂的数据类型：</p>
<p>Un <strong>type algébrique</strong> est une forme de <a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Type_de_donn%C3%A9es">type de données</a> composite<a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Type_alg%C3%A9brique_de_donn%C3%A9es#cite_note-1">note 1, qui combine les fonctionnalités des <strong>types produits</strong> (<em>n</em>‐uplets ou enregistrements) et des <strong>types sommes</strong> (</a><a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Union_disjointe">union disjointe</a>). Combinée à la <a target="_blank" rel="noopener" href="https://fr.wikipedia.org/wiki/Type_r%C3%A9cursif">récursivité</a>, elle permet d’exprimer les données structurées telles que les listes et les arbres.</p>
<p>union conjointe 和 union disjointe分别指笛卡尔乘积和加和</p>
<ol>
<li><p><strong>Types sommes : énumération</strong> 加和类型就是枚举出所有种类</p>
</li>
<li><p><strong>Types produits：tuples</strong> 乘法类型是指一个种类由多个子种类同时组成，例如一个种类有多个参数，类比笛卡尔乘积的各个坐标。</p>
</li>
</ol>
<p>![截屏2022-09-20 18.14.43](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 18.14.43.png)</p>
<h3 id="！！-constructeur-de-donnees"><a href="#！！-constructeur-de-donnees" class="headerlink" title="！！ constructeur de données"></a>！！ constructeur de données</h3><p>在构造新的类型的时候，必须先命名一个<strong>构造器</strong>，构造器constructeur和类型type de donnée在haskell必须以大写字母une majuscule开头。</p>
<p>![截屏2022-09-20 18.20.22](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 18.20.22.png)</p>
<p><strong>注意⚠️隐藏内容：在haskell里面,对象+::+类型，用::来声明或者表示前面数据的类型。</strong></p>
<p><strong>逻辑闭环：函数的类型是由其域的类型决定的，所以课上写f::a-&gt;a，其实就是通过写明函数的域来表明函数的类型。</strong></p>
<p>这里可以看出rien的类型就是data，而valeur的类型其实是一个将double转换成data的函数。所以constructeur本质上就是函数，</p>
<h3 id="！！-constructeur的使用与pattern-matching："><a href="#！！-constructeur的使用与pattern-matching：" class="headerlink" title="！！ constructeur的使用与pattern matching："></a>！！ constructeur的使用与pattern matching：</h3><p>两种使用方式可以调出隐藏起来的值（本质上就是<strong>constructeur函数的自变量</strong>），即<strong>如何求image reciproque的a</strong></p>
<p>一个是在函数传参时，用（constructeur 原值），另一个是let in</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.</span></span><br><span class="line"><span class="title">et</span> <span class="type">True</span> <span class="type">True</span> = <span class="type">True</span></span><br><span class="line"><span class="title">et</span> _ <span class="type">False</span> =<span class="type">False</span></span><br><span class="line"><span class="title">et</span> <span class="type">False</span> _ =<span class="type">False</span></span><br><span class="line"><span class="comment">--2.经典，淋漓尽致</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line"><span class="title">distance</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2) = sqrt ((x1-x2)^<span class="number">2</span>+(y1-y2)^<span class="number">2</span>)</span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vecteur</span> = <span class="type">Vecteur</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Figure</span> = <span class="type">FigP</span> <span class="type">Point</span>|<span class="type">Cercle</span> <span class="type">Point</span> <span class="type">Double</span> | <span class="type">Carre</span> <span class="type">Point</span> <span class="type">Vecteur</span></span></span><br><span class="line"><span class="title">norme</span> ( <span class="type">Vecteur</span> x y ) = distance (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span> ) (<span class="type">Point</span> x y)</span><br><span class="line"></span><br><span class="line"><span class="title">perimetre</span> (<span class="type">FigP</span> _ ) = <span class="number">0</span></span><br><span class="line"><span class="title">perimetre</span> (<span class="type">Cercle</span> _ r ) = <span class="number">2</span>*pi*r</span><br><span class="line"><span class="title">perimetre</span> (<span class="type">Carre</span> _  x ) = <span class="number">4</span> *  $ norme x</span><br></pre></td></tr></table></figure>



<h2 id="3-3-Types-parametres-：含参类型"><a href="#3-3-Types-parametres-：含参类型" class="headerlink" title="3.3 Types paramétrés ：含参类型"></a>3.3 Types paramétrés ：含参类型</h2><p>经典含参类型：</p>
<p>就是这个类型不仅有类型名字。而且还附带一个参数a</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- maybe是非常经典的含参类型，用于计算出现错误时返回错误值，将普通数据和错误数据定义成maybe，如果是错误就输出nothing，否则输出just a ,只是使用过maybe  a ，但没有自己构造过含参类型</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Maybe</span> a = <span class="type">Nothing</span> | <span class="type">Just</span> a</span></span><br><span class="line"><span class="comment">--Maybe 本身就是constructeur de type， 可以有很多参数：</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Either</span> a b = <span class="type">Left</span> a | <span class="type">Right</span> b</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="type">String</span> = [<span class="type">Char</span>] <span class="comment">-- synonyme</span></span></span><br><span class="line"><span class="class"><span class="keyword">newtype</span>  <span class="comment">--没理解</span></span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-Tuple-et-enregistrement-：元组和结构体怎么构造"><a href="#3-4-Tuple-et-enregistrement-：元组和结构体怎么构造" class="headerlink" title="3.4 Tuple et enregistrement ：元组和结构体怎么构造"></a>3.4 Tuple et enregistrement ：元组和结构体怎么构造</h2><h2 id="截屏2022-09-20-22-36-47-x2F-Users-x2F-zhangxin-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-截屏2022-09-20-22-36-47-png"><a href="#截屏2022-09-20-22-36-47-x2F-Users-x2F-zhangxin-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-截屏2022-09-20-22-36-47-png" class="headerlink" title="![截屏2022-09-20 22.36.47](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 22.36.47.png)"></a>![截屏2022-09-20 22.36.47](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 22.36.47.png)</h2><p>1.元组不需要声明，写成(,)自动成为元组，有fst 和 snd，且通过pattern matching更简单</p>
<p>![截屏2022-09-20 22.38.15](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 22.38.15.png)</p>
<p>2.结构体  一种特殊的构造类型，有个印象先，还没用到过。。</p>
<h2 id="3-5-Types-algebriques-recursifs-递归型代数结构，类似链表和树怎么构造"><a href="#3-5-Types-algebriques-recursifs-递归型代数结构，类似链表和树怎么构造" class="headerlink" title="3.5  Types algébriques récursifs 递归型代数结构，类似链表和树怎么构造"></a>3.5  <strong>Types algébriques récursifs</strong> 递归型代数结构，类似链表和树怎么构造</h2><p><strong>包括无限长的链表和树怎么构造。</strong></p>
<p>经典重现，利用Peano的五大公理构造自然数，arithmétique de Peano,自然数是由0和它的后继组成的。</p>
<p><strong>在data type 构造过程中 调用它本身，以后经常用到这种递归性的代数结构</strong></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--系统的讲，这种问题一般来说我们先用data创造出一个抽象的概念，即对创造的东西进行命名，然后在写一个取值函数对抽象的概念进行赋值操作。</span></span><br><span class="line"><span class="comment">--1.</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Nat</span> = <span class="type">Zero</span> | <span class="type">Succ</span> <span class="type">Nat</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">eval</span>::<span class="type">Nat</span>-&gt;<span class="type">Integer</span></span><br><span class="line"><span class="title">eval</span> <span class="type">Zero</span> = <span class="number">0</span></span><br><span class="line"><span class="title">eval</span> (<span class="type">Succ</span> n) = eval n + <span class="number">1</span> </span><br><span class="line"></span><br><span class="line"><span class="title">addition</span>::<span class="type">Nat</span>-&gt;<span class="type">Nat</span>-&gt;<span class="type">Integer</span></span><br><span class="line"><span class="title">addition</span> <span class="type">Zero</span> n = n</span><br><span class="line"><span class="title">addition</span> n <span class="type">Zero</span> = n</span><br><span class="line"><span class="title">addition</span> (<span class="type">Succ</span> x) y = addition x  $ <span class="type">Succ</span> y</span><br><span class="line"><span class="comment">--多写几次这种东西，理解起来不难的</span></span><br><span class="line"><span class="comment">--主要是第一次接触，不好去抽象出想要的数据类型</span></span><br><span class="line"><span class="comment">--2.列表和树怎么构造</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Liste</span> = <span class="type">Vide</span> | <span class="type">Liste</span> <span class="type">Integer</span> <span class="type">Liste</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">sum</span> <span class="type">Vide</span> = <span class="number">0</span></span><br><span class="line"><span class="title">sum</span> ( <span class="type">Liste</span> x xs ) = x + sum xs</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">ArbreBinaire</span> = <span class="type">Empty</span> |<span class="type">ArbreB</span> <span class="type">Integer</span> <span class="type">ArbreBinaire</span> <span class="type">ArbreBinaire</span></span></span><br><span class="line"></span><br><span class="line"><span class="title">hauteur</span> <span class="type">Empty</span> = <span class="number">0</span></span><br><span class="line"><span class="title">hauteur</span> (<span class="type">ArbreB</span> x xl xr ) = <span class="number">1</span> + max $ hauteur xl $ hauteur xr</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h2 id="3-6-Liste-列表"><a href="#3-6-Liste-列表" class="headerlink" title="3.6 Liste 列表"></a>3.6 Liste 列表</h2><p>1.列表的基本操作：</p>
<ul>
<li><p>列表的索引</p>
</li>
<li><p>列表的拼接</p>
</li>
<li><p>列表元素接入列表</p>
</li>
<li><p>列表比较</p>
</li>
<li><p>列表相关函数</p>
</li>
<li><p>en compréhension [a | a&lt;- str , a <code>elem</code>  [‘A’..’Z’] ]</p>
</li>
</ul>
<p>-单行注释</p>
<p>{-多行注释-}</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello world!&quot;</span>!!<span class="number">4</span>  </span><br><span class="line"><span class="comment">--返回o</span></span><br><span class="line">&#x27;a&#x27;++<span class="string">&quot;big world&quot;</span></span><br><span class="line"><span class="comment">--&quot;a big world&quot;</span></span><br><span class="line"><span class="number">1</span>:<span class="number">2</span>:<span class="number">3</span>:[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] </span><br><span class="line"><span class="comment">--列表逐一比较</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]&gt;[<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br><span class="line"><span class="comment">--可以列表套列表但必须统一类型</span></span><br><span class="line"><span class="title">let</span> [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">3</span>,][<span class="number">3</span>,<span class="number">4</span>]]</span><br><span class="line"><span class="comment">--第一元素，最后一个，除第一个，除最后一个，长度，是否为空，反转，提取前nombre个元素，删除最大值，返回最小值，返回最大值，求和，求累乘，判断4是否在列表里。</span></span><br><span class="line"><span class="title">head</span>[]</span><br><span class="line"><span class="title">last</span>[]</span><br><span class="line"><span class="title">tail</span>[]</span><br><span class="line"><span class="title">init</span>[]</span><br><span class="line"><span class="title">length</span>[]</span><br><span class="line"><span class="title">null</span>[]</span><br><span class="line"><span class="title">reverse</span>[]</span><br><span class="line"><span class="title">take</span> nombre []</span><br><span class="line"><span class="title">drop</span> nombre []</span><br><span class="line"><span class="title">minimum</span>[]</span><br><span class="line"><span class="title">maximum</span>[]</span><br><span class="line"><span class="title">sum</span>[]</span><br><span class="line"><span class="title">product</span>[]</span><br><span class="line"><span class="number">4</span> `elem` []</span><br><span class="line"></span><br><span class="line"><span class="comment">--最常用的就是用compréhension赋值</span></span><br><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">和前面赋值语句相同可以加if｜  可以用&lt;-表示遍历+condion来限制</span></span><br><span class="line"><span class="comment">[if x &gt; 10 then &quot;ping else &quot;Pong&quot; | x &lt;- xs, odd x ]</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">[2,4..8]</span></span><br><span class="line"><span class="comment">[20,19..1]</span></span><br><span class="line"><span class="comment">[12,24..12*10]=take 10 [12,24..]</span></span><br><span class="line"><span class="comment">take 9 (cycle [1,2,3])</span></span><br><span class="line"><span class="comment">take 10 (repeat a)</span></span><br><span class="line"><span class="comment">replicate n 10 =输出n个10</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--triplet pythagoricien 勾股数</span></span><br><span class="line"><span class="title">let</span> x = [ (a, b, c) |a&lt;-[<span class="number">1</span>..<span class="number">333</span>],b&lt;-[a+<span class="number">1</span>..<span class="number">1000</span>],<span class="number">1000</span>-a-b&lt;-[b+<span class="number">1</span>],a^<span class="number">2</span>+b^<span class="number">2</span>=(<span class="number">1000</span>-a-b)^<span class="number">2</span> ]</span><br><span class="line"></span><br><span class="line"><span class="title">reverse</span> [] = []</span><br><span class="line"><span class="title">reverse</span> (x:xs) = reverse xs ++  [x]</span><br><span class="line"></span><br><span class="line"><span class="title">reverse&#x27;</span> [] r = r</span><br><span class="line"><span class="title">reverse&#x27;</span> (x:xs) r = reverse xs (x : r)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"><span class="title">delete</span> a [] = []</span><br><span class="line"><span class="title">delete</span> a (x:xs) = <span class="keyword">if</span> a == x <span class="keyword">then</span> xs <span class="keyword">else</span> x : delete a xs</span><br><span class="line"></span><br><span class="line"><span class="title">maximum</span> [] = error</span><br><span class="line"><span class="title">maximum</span> [x] = x</span><br><span class="line"><span class="title">maximum</span> (x:xs) = max x $ maximum xs </span><br><span class="line"></span><br><span class="line"><span class="title">trimax</span> [] = []</span><br><span class="line"><span class="title">trimax</span> xs =<span class="keyword">let</span> y = maximum xs <span class="keyword">in</span>. y : trimax $ delete y xs</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Prelude 序章</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="3-7-Types-generiques"><a href="#3-7-Types-generiques" class="headerlink" title="3.7 Types génériques"></a>3.7 Types génériques</h2><p>这里的意思就是任意的，更加generale的，类型可以随意定义的意思。</p>
<h2 id="截屏2022-09-21-19-01-15-x2F-Users-x2F-zhangxin-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-截屏2022-09-21-19-01-15-png"><a href="#截屏2022-09-21-19-01-15-x2F-Users-x2F-zhangxin-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-截屏2022-09-21-19-01-15-png" class="headerlink" title="![截屏2022-09-21 19.01.15](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-21 19.01.15.png)"></a>![截屏2022-09-21 19.01.15](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-21 19.01.15.png)</h2><h2 id="IV-Fonctions-d’ordre-superieur-高阶函数"><a href="#IV-Fonctions-d’ordre-superieur-高阶函数" class="headerlink" title="IV. Fonctions d’ordre supérieur:高阶函数"></a>IV. Fonctions d’ordre supérieur:高阶函数</h2><p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E5%AD%A6">数学</a>和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中，<strong>高阶函数</strong>是至少满足下列一个条件的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>：</p>
<ul>
<li>接受一个或多个函数作为输入</li>
<li>输出一个函数</li>
</ul>
<p>在数学中它们也叫做<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%97%E5%AD%90">算子</a>（运算符）或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%87%BD">泛函</a>。<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E7%A7%AF%E5%88%86">微积分</a>中的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AF%BC%E6%95%B0">导数</a>就是常见的例子，因为它映射一个函数到另一个函数。</p>
<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Lambda%E6%BC%94%E7%AE%97">无类型lambda演算</a>，所有函数都是高阶的；在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9C%89%E7%B1%BB%E5%9E%8Blambda%E6%BC%94%E7%AE%97">有类型lambda演算</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-cn/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0#cite_note-1">注 1]</a>中，高阶函数一般是那些函数型别包含多于一个箭头的函数。在函数式编程中，返回另一个函数的高阶函数被称为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Curry%E5%8C%96">Curry化</a>的函数。</p>
<p>在很多函数式编程语言中能找到的<code>map</code>函数是高阶函数的一个例子。它接受一个函数<strong>f</strong>作为参数，并返回接受一个列表并应用<strong>f</strong>到它的每个元素的一个函数。高阶函数的其他例子包括:</p>
<ul>
<li>常量函数λ<em>x</em>.λ<em>y</em>.<em>x</em>。</li>
<li>排序函数，接受一个比较函数作为参数。</li>
<li><code>filter</code>函数</li>
<li><code>fold</code>函数</li>
<li><code>apply函数</code></li>
<li><code>函数复合</code></li>
<li><code>积分</code></li>
</ul>
<h2 id="4-1-Currification-“Curring”"><a href="#4-1-Currification-“Curring”" class="headerlink" title="4.1 Currification “Curring”:"></a>4.1 Currification “Curring”:</h2><p><strong>柯里化</strong>是一种处理函数中附有多个参数的方法，并在只允许单一参数的框架中使用这些函数。例如，一些分析技术只能用于具有单一参数的函数。现实中的函数往往有更多的参数。弗雷格表明，为单一参数情况提供解决方案已经足够了，因为可以将具有多个参数的函数转换为一个单参数的函数链。这种转变是现在被称为“柯里化”的过程。函数柯里化的对偶是<strong>Uncurrying</strong></p>
<p>以max函数为例，柯里化的意思是 max x y 有两个参数，但是可以理解为 max 只有一个参数x，</p>
<p>返回了 （max x ） 也是一个参数的函数 同时返回一个整数，也就是输入一个整型返回一个输入整型输出整型的函数。</p>
<p>max :: Integer-&gt;(Integer-&gt;Integer)</p>
<p>![截屏2022-09-21 19.17.49](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-21 19.17.49.png)</p>
<p>![截屏2022-09-21 19.25.36](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-21 19.25.36.png)</p>
<p>也就是说：多变一，一变多</p>
<p><strong>curry::((a,b)-&gt;c)-&gt;(a-&gt;(b-&gt;c))</strong></p>
<p><strong>uncurry::(a-&gt;(b-&gt;c))-&gt;((a,b)-&gt;c)</strong></p>
<p>在haskell里函数默认是curryed的所以在理解haskell里的函数是的小技巧就是</p>
<p>函数1 ：： 参数1-&gt;参数2-&gt;参数3-&gt;..-&gt;返回值，理解的时候，<strong>在右面可以任意加括号,因为你可以直接往里面代值，但是左面不可以</strong>，且<strong>如果参数不够，就假设加上</strong>，后面题会很好理解。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span>::(a-&gt;b)-&gt;[a]-&gt;[b]</span><br><span class="line"></span><br><span class="line"><span class="title">flip</span>::(a-&gt;b-&gt;c)-&gt;b-&gt;a-&gt;c</span><br><span class="line"><span class="title">flip</span> (-) <span class="number">1</span> <span class="number">3</span> = <span class="number">3</span> - <span class="number">1</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-Application-de-fonction-两种用法-函数赋值"><a href="#4-2-Application-de-fonction-两种用法-函数赋值" class="headerlink" title="4.2 Application de fonction $ 两种用法 函数赋值 ($)"></a>4.2 Application de fonction $ 两种用法 函数赋值 ($)</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1.application</span></span><br><span class="line">($)::(a-&gt;b)-&gt;a-&gt;b</span><br><span class="line">($) f x = f x</span><br><span class="line"></span><br><span class="line"><span class="comment">--2.Elle est de faible priorité et associative à droite : 优先算右面的，算完在算左面的</span></span><br><span class="line"><span class="title">main</span> = print (square (inc <span class="number">2</span>))</span><br><span class="line"><span class="comment">-- ou un peu plus concis</span></span><br><span class="line"><span class="title">main</span> = print $ square $ inc <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--3.Elle sert pour définir certaines fonctions d’ordre supérieur : 给f g h赋值0</span></span><br><span class="line"><span class="title">map</span> ($ <span class="number">0</span>) [f,g,h]</span><br></pre></td></tr></table></figure>



<h2 id="4-3-Fonctions-anonymes-Fonctions-λ"><a href="#4-3-Fonctions-anonymes-Fonctions-λ" class="headerlink" title="4.3 Fonctions anonymes (Fonctions λ)"></a>4.3 <strong>Fonctions anonymes (Fonctions</strong> λ)</h2><p><strong>匿名函数</strong>（英语：Anonymous Function）在计算机编程中是指一类无需定义<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a>（函数名）的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0">函数</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">子程序</a></p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">inc</span> x = x+<span class="number">1</span></span><br><span class="line"><span class="title">map</span> inc [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">-- ou simplement</span></span><br><span class="line"><span class="title">map</span> (\x -&gt; x+<span class="number">1</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="comment">-- plusieurs variables:</span></span><br><span class="line"><span class="title">add</span> = (\x y -&gt; x+y)</span><br></pre></td></tr></table></figure>

<h2 id="4-4-Fermetures-Closures-闭包："><a href="#4-4-Fermetures-Closures-闭包：" class="headerlink" title="4.4 Fermetures (Closures) 闭包："></a>4.4 Fermetures (Closures) 闭包：</h2><p>闭包和<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</a>经常被用作同义词。但严格来说，匿名函数就是字面意义上没有被赋予名称的函数，而闭包则实际上是一个函数的实例，也就是说它是存在于内存里的某个结构体。如果从实现上来看的话，匿名函数如果没有捕捉自由变量，那么它其实可以被实现为一个函数指针，或者直接内联到调用点，如果它捕捉了自由变量那么它将是一个闭包；而闭包则意味着同时包括函数指针和环境两个关键元素。在编译优化当中，没有捕捉自由变量的闭包可以被优化成普通函数，这样就无需分配闭包结构体，这种编译技巧被称为<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lambda_lifting">函数跃升</a></p>
<ul>
<li>自由变量，约束变量</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Pour tout y, g y est une fermeture!</span></span><br><span class="line"><span class="title">g</span> y = (\x -&gt; x + y)</span><br><span class="line"><span class="comment">--类似map其实也是闭包，柯里化的过程其实就是构建闭包的过程，例如max x 返回了一个函数，这就叫闭包了额？我对这个没理解到位还。</span></span><br></pre></td></tr></table></figure>

<h2 id="4-5‼️⚠️recursion-sur-les-listes-应用到listes的函数map-filter-foldl-foldr"><a href="#4-5‼️⚠️recursion-sur-les-listes-应用到listes的函数map-filter-foldl-foldr" class="headerlink" title="4.5‼️⚠️récursion sur les listes 应用到listes的函数map filter foldl foldr"></a>4.5‼️⚠️récursion sur les listes 应用到listes的函数map filter foldl foldr</h2><h3 id="‼️第四章最重要部分"><a href="#‼️第四章最重要部分" class="headerlink" title="‼️第四章最重要部分"></a>‼️第四章最重要部分</h3><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--1. map:</span></span><br><span class="line"><span class="title">map</span>::(a-&gt;b)-&gt;[a]-&gt;[b]</span><br><span class="line"><span class="title">map</span> _ [] = []</span><br><span class="line"><span class="title">map</span> f (x:xs) = (f x):(map f xs)</span><br><span class="line"><span class="comment">--map f xs = [ f x | x&lt;-xs ] </span></span><br><span class="line"></span><br><span class="line"><span class="comment">--2.filter</span></span><br><span class="line"><span class="title">filter</span>::(a-&gt;<span class="type">Bool</span>)-&gt;[a]-&gt;[a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> f (x:xs) = <span class="keyword">if</span> f x <span class="keyword">then</span> x:(filter f xs) <span class="keyword">else</span> filter f xs</span><br><span class="line"><span class="comment">--filter f xs = [ x | x&lt;-xs, f x ] </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--3.foldr foldl</span></span><br><span class="line"><span class="title">foldl</span>::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b</span><br><span class="line"><span class="title">foldl</span> f x [] = x</span><br><span class="line"><span class="title">foldl</span> f x (y:ys) = foldl f (f x y) ys</span><br><span class="line"></span><br><span class="line"><span class="title">foldr</span>::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b</span><br><span class="line"><span class="title">foldr</span> f x [] = x</span><br><span class="line"><span class="title">foldr</span> f x (y:ys) = f y (foldr f x ys)</span><br><span class="line"></span><br><span class="line"><span class="comment">-- foldl1,foldr1::(a-&gt;a-&gt;a)-&gt;[a]-&gt;a sont des versions sans élément de départ pour les listes non vides ;</span></span><br></pre></td></tr></table></figure>

<p>应用：</p>
<ul>
<li><p><strong>map f [a]  返回一个列表，每个元素都执行一遍f</strong></p>
</li>
<li><p><strong>filter f [a]  返回一个列表，只包含满足f x 为真的元素</strong></p>
</li>
<li><p><strong>fold f  x [a] 返回一个值，分别从左面或者右面一次，用f 相互做运算</strong></p>
</li>
<li><p>concat 去掉[]</p>
</li>
<li><p><strong>Eq a &#x3D;&gt; a : 意思是 这个a类型是属于 Eq a 类型的，满足Eq a类里规定的运算。</strong></p>
</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&#123;-</span></span><br><span class="line"><span class="comment">1.号称最难的</span></span><br><span class="line"><span class="comment">En utilisant map, écrire une fonction an qui donne la liste de toutes les anagrammes 变体 d’un mot.</span></span><br><span class="line"><span class="comment">On pourra utiliser aussi :</span></span><br><span class="line"><span class="comment">• concat::[[a]]-&gt;[a]</span></span><br><span class="line"><span class="comment">• delete::Eq a =&gt;a-&gt;[a]-&gt;[a]</span></span><br><span class="line"><span class="comment">-&#125;</span></span><br><span class="line"><span class="comment">--我咋觉得我写的对？？</span></span><br><span class="line"><span class="title">an</span> <span class="string">&quot;&quot;</span>=[]</span><br><span class="line"><span class="title">an</span>  xs  = concat $ map (\x-&gt;  map (x:)  $ an $ delete x xs) $ nub xs </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="V-Methodes-d’evaluation-几种赋值方法"><a href="#V-Methodes-d’evaluation-几种赋值方法" class="headerlink" title="V. Méthodes d’évaluation: 几种赋值方法"></a>V. Méthodes d’évaluation: 几种赋值方法</h2><p>赋值优先级：priorité d’évaluation 有两种赋值优先级：</p>
<p>1.évaluation stricte (Java C python)</p>
<p>总是要优先计算argument，将argument的值全部算出来évalué之后，总的函数才去计算évalué</p>
<p>2.évaluation non stricte-lazy (Haskell)</p>
<p>只有当我们需要的时候才会赋值去求，这种特点可以让我们构造construction infinie</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fibs</span> ::[<span class="type">Integer</span>]</span><br><span class="line"><span class="title">fibs</span> = <span class="number">0</span>:<span class="number">1</span>: zipWith (+) fibs (tail fibs)</span><br><span class="line"><span class="comment">-- le 1234567e nombre de Fibonacci</span></span><br><span class="line"><span class="title">main</span> = print $ fibs !! <span class="number">1234567</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--注意⚠️zipwith,take,takewhile,drop,dropwhile用法</span></span><br></pre></td></tr></table></figure>

<p><em>•</em> Mais foldr n’est pas récursif terminal et peut donc remplir la mémoire avec les opérations en attente sur de</p>
<p> grosses listes ; 会存很多</p>
<p><em>•</em> foldl ne peut pas fonctionner sur des listes infinies mais est <strong>récursif terminal</strong>. 不会存很多</p>
<p>这两句话怎么理解？</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--foldl réduit de la gauche vers la droite :</span></span><br><span class="line"><span class="title">foldl</span>::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b</span><br><span class="line"><span class="title">foldl</span> f x [] = x</span><br><span class="line"><span class="title">foldl</span> f x (y:ys) = foldl f (f x y) ys</span><br><span class="line"><span class="comment">--foldr réduit de la droite vers la gauche :</span></span><br><span class="line"><span class="title">foldr</span>::(a-&gt;b-&gt;b)-&gt;b-&gt;[a]-&gt;b</span><br><span class="line"><span class="title">foldr</span> f x [] = x</span><br><span class="line"><span class="title">foldr</span> f x (y:ys) = f y (foldr f x ys)</span><br></pre></td></tr></table></figure>



<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--foldr可以作用在无限长</span></span><br><span class="line"><span class="title">any</span>::(a-&gt;<span class="type">Bool</span>)-&gt;[a]-&gt;<span class="type">Bool</span></span><br><span class="line"><span class="title">any</span> f = (foldr (||) <span class="type">False</span>).(map f)</span><br><span class="line"><span class="title">main</span> = <span class="keyword">do</span></span><br><span class="line"><span class="comment">-- Ceci donne vrai</span></span><br><span class="line"><span class="title">print</span> $ any even [<span class="number">1</span>..]</span><br><span class="line"><span class="comment">-- Mais ceci boucle indéfiniment</span></span><br><span class="line"><span class="title">print</span> $ any (\x-&gt;<span class="type">False</span>) [<span class="number">1</span>..]</span><br></pre></td></tr></table></figure>

<p>一种用seq函数解决foldl不能作用在无限长数列的方法</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--On peut forcer l’évaluation de f avec foldl&#x27; :</span></span><br><span class="line"><span class="title">foldl</span> &#x27;::(b-&gt;a-&gt;b)-&gt;b-&gt;[a]-&gt;b</span><br><span class="line"><span class="title">foldl</span> &#x27; f z [] = z</span><br><span class="line"><span class="title">foldl</span> &#x27; f z (x:xs) = <span class="keyword">let</span> z&#x27; = f z x</span><br><span class="line"><span class="title">in</span> seq z&#x27; (foldl &#x27; f z&#x27; xs)</span><br><span class="line"><span class="comment">--seq::a-&gt;b-&gt;b évalue son premier argument puis donne le deuxième comme résultat.</span></span><br></pre></td></tr></table></figure>



<h2 id="VI-Entrees-Sorties-输入输出"><a href="#VI-Entrees-Sorties-输入输出" class="headerlink" title="VI. Entrées, Sorties: 输入输出"></a>VI. Entrées, Sorties: 输入输出</h2><p>在haskell中输入输出是一种特殊的数据类型type paramétré I0 ()</p>
<p>putStr-putStrLn 是一类的将字符串输出 ，getLine - getChar 从clavier读字符串和字母</p>
<p>print 是输出任意类型</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- Écrire à l&#x27;écran</span></span><br><span class="line"><span class="comment">-- () est le type dit unitaire qui représente &quot;rien&quot;</span></span><br><span class="line"><span class="title">putStr</span>::<span class="type">String</span> -&gt;<span class="type">IO</span> ()</span><br><span class="line"><span class="title">putStrLn</span>::<span class="type">String</span> -&gt;<span class="type">IO</span> () <span class="comment">-- saute une ligne à la fin</span></span><br><span class="line"><span class="comment">-- Affichage &quot;intelligent&quot; pour les instance de Show</span></span><br><span class="line"><span class="title">print</span>::(<span class="type">Show</span> a) =&gt; a -&gt; <span class="type">IO</span> ()</span><br><span class="line"><span class="title">print</span> = putStrLn.show</span><br><span class="line"><span class="comment">-- Lire au clavier</span></span><br><span class="line"><span class="title">getLine</span>::<span class="type">IO</span> <span class="type">String</span> <span class="comment">-- une ligne</span></span><br><span class="line"><span class="title">getChar</span>::<span class="type">IO</span> <span class="type">Char</span> <span class="comment">-- un caractère</span></span><br><span class="line"><span class="comment">-- Dual de Show</span></span><br><span class="line"><span class="title">read</span>::(<span class="type">Read</span> a)=&gt;<span class="type">String</span> -&gt;a</span><br></pre></td></tr></table></figure>



<p>在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B">函数式编程</a>中，<strong>单子</strong>（monad）是一种抽象，它允许以<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B">泛型</a>方式构造程序。支持它的语言可以使用单子来抽象出程序逻辑需要的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81&action=edit&redlink=1">样板代码</a>。为了达成这个目标，单子提供它们自己的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a>（每种类型的单子都有特定的类型），它表示一种特殊形式<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97">计算</a>，与之在一起的有两个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A8%8B%E5%BA%8F">过程</a>，一个过程用来包装单子内“任何”基本类型的值（产生<strong>单子值</strong>），另一个过程用来<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E5%87%BD%E6%95%B0%E5%A4%8D%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)&action=edit&redlink=1">复合</a>那些输出单子值的函数（叫做<strong>单子函数</strong>）[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-RealWorldHaskell-1">1]</a>。</p>
<p>单子的概念和术语二者最初都来自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%8C%83%E7%95%B4%E8%AE%BA">范畴论</a>，这里的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%96%AE%E5%AD%90_(%E7%AF%84%E7%96%87%E8%AB%96)">单子</a>被定义为具有额外结构的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%AD%90">函子</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-3">a]</a>。开始于1980年代晚期和1990年代早期的研究，确立了单子可以将看似完全不同的计算机科学问题置于一个统一的函数式模型之下。范畴论还提供了叫做<strong>单子定律</strong>的一些形式要求，任何单子都应当满足它并可以用它来<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E9%AA%8C%E8%AF%81">验证</a>单子代码[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-Moggi1991-2">2]</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-Wadler1992-4">3]</a>。</p>
<p>通过单子，编程者可以把复杂的函数序列变成简洁的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%AE%A1%E9%81%93_(%E8%BD%AF%E4%BB%B6)">管道</a>，它抽象出了辅助数据管理、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E6%B5%81">控制流</a>或<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">副作用</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-RealWorldHaskell-1">1]</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-Wadler1990-5">4]</a>。单子可以简化范围宽广的问题，比如处理潜在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/w/index.php?title=%E6%9C%AA%E5%AE%9A%E4%B9%89%E5%80%BC&action=edit&redlink=1">未定义值</a>（通过<code>Maybe</code>单子），或将值保持在一个灵活而形式正确的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%88%97%E8%A1%A8_(%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B)">列表</a>中（使用<code>List</code>单子）。因为单子使得某种计算的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E4%B9%89%E5%AD%A6">语义</a>明确，它们还可以用来实现便捷的语言特征。一些语言比如<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Haskell">Haskell</a>，甚至在它们的核心<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%87%BD%E5%BC%8F%E5%BA%AB">库</a>中为通用单子结构提供预制的定义和常用实例[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-RealWorldHaskell-1">1]</a>[<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%AD%90_(%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B)#cite_note-GentleIntroHaskell-6">5]</a></p>
<h2 id="exercice"><a href="#exercice" class="headerlink" title="exercice:"></a>exercice:</h2><ol>
<li>puissance x 0 &#x3D; 1</li>
</ol>
<p>	</p>
<p>puissance x n&#x3D; x* puissance x (n-1)</p>
<p>n</p>
<p>2. </p>
<p>Div x 2 quoi</p>
<p>Mod x 2 rem</p>
<ol start="3">
<li><p>complexité temporelle :</p>
<p>n et log n</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>.</span><br><span class="line"><span class="type">Puissance&#x27;</span> x <span class="number">0</span>= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="type">Puissance&#x27;</span> x n = <span class="keyword">if</span> even n <span class="keyword">then</span> puissance&#x27; (x*x) (div n <span class="number">2</span>) <span class="keyword">else</span> puissance x*puissance&#x27; (x\*x)  (div n <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li>
</ol>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">version</span> exponentielle:</span><br><span class="line"><span class="type">Fibonnacci</span> <span class="number">0</span> = <span class="number">0</span></span><br><span class="line"><span class="type">Fibonnacci</span> <span class="number">1</span> = <span class="number">1</span></span><br><span class="line"><span class="type">Fibonnacci</span> n =<span class="type">Fibonnacci</span> (n-<span class="number">1</span>) +<span class="type">Fibonnnacci</span> (n-<span class="number">2</span>)</span><br><span class="line"><span class="type">Fibonnacci</span> n r =  <span class="type">Fibonnacci</span> (n-<span class="number">1</span>) (n-<span class="number">1</span>+n-<span class="number">2</span>+r)</span><br><span class="line"><span class="title">version</span> linéaire:</span><br><span class="line"><span class="type">Fibonnacci</span> <span class="number">0</span> _ n= n</span><br><span class="line"><span class="type">Fibonnacci</span> r m n =<span class="type">Fibonnacci</span> (r-<span class="number">1</span>) m+n m</span><br><span class="line"><span class="type">Fibonnacci&#x27;</span> r= <span class="type">Fibonnacci</span> r <span class="number">1</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lychrel</span> numbers</span><br><span class="line"><span class="title">hpal</span> n = <span class="keyword">if</span> n== r n <span class="keyword">then</span> <span class="number">0</span> <span class="keyword">else</span> <span class="number">1</span> + hpal (n+r n)</span><br><span class="line"></span><br><span class="line"><span class="title">r</span> :: <span class="type">Integer</span>-&gt;<span class="type">Integer</span> </span><br><span class="line"><span class="title">r&#x27;</span> <span class="number">0</span> m = m</span><br><span class="line"><span class="title">r&#x27;</span> n m a=  r (div n <span class="number">10</span>) ((mod n <span class="number">10</span>)+ <span class="number">10</span>*m) </span><br><span class="line"><span class="title">r</span> n =r&#x27; n <span class="number">0</span></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getVal::PossibleReel-Double</span><br><span class="line">getVal Rien=error&quot;no value&quot;</span><br><span class="line">getVal (Valeur x)=x</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="et-logique"><a href="#et-logique" class="headerlink" title="et logique:"></a>et logique:</h2><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span>= <span class="type">True</span> | <span class="type">False</span></span></span><br><span class="line"><span class="title">et</span>::<span class="type">Bool</span>-&gt;<span class="type">Bool</span></span><br><span class="line"><span class="title">et</span> <span class="type">True</span> <span class="type">True</span>=<span class="type">True</span></span><br><span class="line"><span class="title">et</span> _ _ =<span class="type">False</span></span><br></pre></td></tr></table></figure>



<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span>= <span class="type">Point</span> <span class="type">Double</span> <span class="type">Double</span> deriveng <span class="type">Show</span> <span class="comment">-- x y</span></span></span><br><span class="line"><span class="title">distance</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)=sqrt (x1-x2)^<span class="number">2</span>+(y1-y2)^<span class="number">2</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vecteur</span>=<span class="type">Vecteur</span> <span class="type">Double</span> <span class="type">Double</span></span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Figure</span> = <span class="type">FigP</span> <span class="type">Point</span>|<span class="type">Cercle</span> <span class="type">Double</span> <span class="type">Point</span>|<span class="type">Carr</span>é <span class="type">Point</span> <span class="type">Vecteur</span></span></span><br><span class="line"><span class="title">perimetre</span>::<span class="type">Figure</span>-&gt;<span class="type">Double</span></span><br><span class="line"><span class="title">norme</span> (<span class="type">Vecteur</span> x y)=distance (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) (<span class="type">Point</span> x y)</span><br><span class="line"><span class="title">perimetre</span> (<span class="type">FigP</span> _)=<span class="number">0</span> <span class="comment">--(FigP (Point x y))</span></span><br><span class="line"><span class="title">perimetre</span> (<span class="type">Cercle</span> _ x1)=<span class="number">2</span>*pi*x1  <span class="comment">--(Cercle (Point x y) x)</span></span><br><span class="line"><span class="title">perimetre</span> (<span class="type">Carr</span>é _ <span class="type">V</span>)=<span class="number">4</span>*norme <span class="type">V</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">++ 拼接字符串</span><br><span class="line">皮亚诺公理：</span><br><span class="line">data Nat = Zero | Succ Nat </span><br><span class="line"></span><br><span class="line">eval :: Nat-&gt;Interger</span><br><span class="line">eval Zero = 0</span><br><span class="line">eval (Succ n) =1+eval n</span><br><span class="line"></span><br><span class="line">addition Zero n=n</span><br><span class="line">addition (Succ n1) n2 = addition n1 (Succ n2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> Écrire un <span class="class"><span class="keyword">type</span> <span class="type">Liste</span> représentant une liste d’entiers ;</span></span><br><span class="line"><span class="number">2</span> Écrire une fonction sum qui fait la somme des éléments d’une liste d’entiers ;</span><br><span class="line"><span class="number">3</span> Écrire un <span class="class"><span class="keyword">type</span> <span class="type">ArbreBinaire</span> représentant un arbre binaire d’entiers ;</span></span><br><span class="line"><span class="number">4</span> Écrire une fonction hauteur qui calcule la hauteur d’un arbre binaire d’entiers.</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="class"><span class="keyword">data</span> <span class="type">Liste</span>=<span class="type">Vide</span>|<span class="type">Cons</span> <span class="type">Integer</span> <span class="type">Liste</span></span></span><br><span class="line"><span class="number">2</span>. sum::<span class="type">Liste</span>-&gt;<span class="type">Integer</span></span><br><span class="line">   sum <span class="type">Vide</span>=<span class="number">0</span></span><br><span class="line">   sum (<span class="type">Cons</span> x xs)=x+sum xs</span><br><span class="line">   sum(<span class="type">Cons</span> <span class="number">1</span>(<span class="type">Cons</span> <span class="number">2</span>(<span class="type">Cons</span> <span class="number">3</span> <span class="type">Vide</span>)))</span><br><span class="line"><span class="number">3</span>. date <span class="type">Arbre</span>=<span class="type">VideA</span>|<span class="type">ConsA</span> <span class="type">Integer</span> <span class="type">Arbre</span> <span class="type">Arbre</span></span><br><span class="line"><span class="number">4</span>. hauteur::<span class="type">Arbre</span>-&gt;<span class="type">Integer</span></span><br><span class="line">   hauteur <span class="type">VideA</span> = <span class="number">0</span></span><br><span class="line">   hauteur (<span class="type">Cons</span> _ x1 x2)=<span class="number">1</span>+max (hauteur x1) (hauteur x2)</span><br><span class="line">   hauteur(<span class="type">ConsA</span> <span class="number">1</span> (<span class="type">ConsA</span> <span class="number">2</span> (<span class="type">ConsA</span> <span class="number">4</span> videA videA) <span class="type">ConsA</span> <span class="number">5</span> <span class="type">VideA</span> <span class="type">VideA</span>)) <span class="type">VideA</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pytha</span> = [(a,b,c)|a&lt;-[<span class="number">1</span>..<span class="number">333</span>], b&lt;-[(a+<span class="number">1</span>)..<span class="number">500</span>], c&lt;-[(b+<span class="number">1</span>)..<span class="number">1000</span>], a*a+b*b==c*c, a+b+c==<span class="number">1000</span>]</span><br><span class="line"><span class="title">pytha</span> = [(a,b,<span class="number">1000</span>-a-b)|a&lt;-[<span class="number">1</span>..<span class="number">333</span>], b&lt;-[(a+<span class="number">1</span>)..<span class="number">500</span>],  a*a+b*b==(<span class="number">1000</span>-a-b)*(<span class="number">1000</span>-a-b)]</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse</span>::<span class="type">List</span>-&gt;<span class="type">List</span></span><br><span class="line"><span class="title">reverse</span> []=[]</span><br><span class="line"><span class="title">reverse</span> (x:xs)=reverse xs ++ [x]</span><br><span class="line"></span><br><span class="line"><span class="title">reverse&#x27;</span> [] rs = rs</span><br><span class="line"><span class="title">reverse&#x27;</span> (x:xs) rs = reverse&#x27; xs (x:rs)</span><br><span class="line"><span class="title">reverse&#x27;&#x27;</span> xs =reverse&#x27; xs []</span><br><span class="line"></span><br><span class="line"><span class="title">delete</span>::<span class="type">List</span>-&gt;<span class="type">List</span></span><br><span class="line"><span class="title">delete</span> (x:xs) = xs</span><br><span class="line"></span><br><span class="line"><span class="title">suppr</span> x [] = []</span><br><span class="line"><span class="title">suppr</span> x (y:ys) = <span class="keyword">if</span> x == y <span class="keyword">then</span> ys <span class="keyword">else</span> ys:suppr x ys</span><br><span class="line"></span><br><span class="line"><span class="title">maximum</span> [] = error <span class="string">&quot;list vide&quot;</span></span><br><span class="line"><span class="title">maximum</span> [a] = a</span><br><span class="line"><span class="title">maximum</span> (x:xs) = max x (maximum xs)</span><br><span class="line"></span><br><span class="line"><span class="title">trimax</span>  xs = <span class="keyword">let</span> y = maximum xs </span><br><span class="line">						 <span class="keyword">in</span> y : trimax (suppr y xs)</span><br><span class="line">						 </span><br><span class="line"><span class="keyword">import</span> Data.List (<span class="title">sort</span>,<span class="title">delete</span>)</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">qualified</span> Data.List <span class="keyword">as</span> L</span><br><span class="line"><span class="type">L</span>.sort</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">map::(a-&gt;b)-&gt;([a]-&gt;[b])</span><br><span class="line">flip::(a-&gt;b-&gt;c)-&gt;(b-&gt;c-&gt;a)</span><br><span class="line">flip f x y = f y x</span><br><span class="line">- 1 3 = -2</span><br><span class="line">flip (-) 1 3 = - 3 1 = 2</span><br><span class="line"></span><br><span class="line">括号的含义：</span><br><span class="line">de faible priorité et associative à droite</span><br><span class="line"></span><br><span class="line">mod x y = x `mod` y</span><br><span class="line">(+) x y = x + y</span><br><span class="line">(+ 2)</span><br><span class="line">(/ 2)</span><br><span class="line">($ 0)</span><br><span class="line"></span><br><span class="line">zipWith 操作 第一个表 第二个表 </span><br><span class="line">依次对两个表每个元素进行操作。</span><br><span class="line"></span><br><span class="line">		 fibs 0 1 1 2 3</span><br><span class="line">tail fibs 1 1 2 3</span><br><span class="line">          1 2 3 5</span><br><span class="line">          </span><br><span class="line">take 数量 表</span><br><span class="line">取前数量个表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">let e = Dec(Neg(Inc(Val 4)))</span><br><span class="line">evaluate e</span><br><span class="line">let e2 = Inv (Val 0)</span><br><span class="line"></span><br><span class="line">evaluate e2</span><br><span class="line"></span><br><span class="line">isZero (Just 2)</span><br><span class="line">isZero (Just 0)</span><br><span class="line">isZero (Nothing)</span><br><span class="line"></span><br><span class="line">haskell是有惰性的</span><br><span class="line"></span><br><span class="line">## 查缺补漏总结经验-这里主要是我模糊的，刚知道的：</span><br><span class="line"></span><br><span class="line">&amp;&amp; || not</span><br><span class="line"></span><br><span class="line"> mod div odd even /= _</span><br><span class="line"></span><br><span class="line">:t + 表达式获得类型</span><br><span class="line"></span><br><span class="line">## 1.列表的操作：</span><br><span class="line"></span><br><span class="line">列表的操作是haskell的核心内容：</span><br><span class="line"></span><br><span class="line">```haskell</span><br><span class="line">--1.基本操作</span><br><span class="line">--列表拼接用++，元素用:</span><br><span class="line">&#x27;a&#x27;:&#x27;b&#x27;:[&#x27;c&#x27;]</span><br><span class="line">[1,2,3]++[4,5]</span><br><span class="line">--获取索引</span><br><span class="line">[1,2,3]!!4</span><br><span class="line"></span><br><span class="line">--2.list en comprehension 类似set comprehension，[|]竖线右面写变量取值范围和predicate限制条件&gt;,&lt;,== ，左边写表达式和if做交集elem，也可以嵌套，类似python矩阵生成，和对角线的例子</span><br><span class="line">--3.列表相关</span><br><span class="line">--3.1列表操作 </span><br><span class="line">map</span><br><span class="line">(++)</span><br><span class="line">filter</span><br><span class="line">head</span><br><span class="line">last</span><br><span class="line">tail</span><br><span class="line">tail</span><br><span class="line">init</span><br><span class="line">(!!)</span><br><span class="line">null</span><br><span class="line">length</span><br><span class="line">reverse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">--3.2</span><br><span class="line">take</span><br><span class="line">drop</span><br><span class="line">takeWhile</span><br><span class="line">dropWhile</span><br><span class="line">cycle</span><br><span class="line">repeat</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">```</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="Maybe-mfmap-组成了foncteur"><a href="#Maybe-mfmap-组成了foncteur" class="headerlink" title="Maybe + mfmap 组成了foncteur"></a>Maybe + mfmap 组成了foncteur</h4><h4 id="prouvoir操作-lift-a-gt-b-gt-m-a-gt-m-b-将一个从a到b的函数变成从m-a到m-b的函数"><a href="#prouvoir操作-lift-a-gt-b-gt-m-a-gt-m-b-将一个从a到b的函数变成从m-a到m-b的函数" class="headerlink" title="prouvoir操作 lift (a-&gt;b)-&gt;(m a)-&gt;(m b) 将一个从a到b的函数变成从m a到m b的函数"></a>prouvoir操作 lift (a-&gt;b)-&gt;(m a)-&gt;(m b) 将一个从a到b的函数变成从m a到m b的函数</h4><p>未完待不续了，懒癌</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Xin Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/16/PFONC-CM/">http://example.com/2022/10/16/PFONC-CM/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">著作权归作者所有。商业转载请联络作者获得授权，非商业转载请标明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/PFONC/">PFONC</a><a class="post-meta__tags" href="/tags/Haskell/">Haskell</a><a class="post-meta__tags" href="/tags/ECN/">ECN</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="/img/ECN.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-full"><a href="/2022/10/16/algoa-cm/"><img class="prev-cover" src="/img/ECN.jpg" onerror="onerror=null;src='/img/codes.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">ALGOA课堂笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/10/16/TP1_RSA/" title="PFONC-TP1"><img class="cover" src="/img/lake.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PFONC-TP1</div></div></a></div><div><a href="/2022/10/16/TP2_demineur/" title="PFONC-TP2"><img class="cover" src="/img/lake.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PFONC-TP2</div></div></a></div><div><a href="/2022/10/16/TP3_puissance4/" title="PFONC-TP3"><img class="cover" src="/img/lake.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PFONC-TP3</div></div></a></div><div><a href="/2022/10/16/PFONC_%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/" title="PFONC-总结"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PFONC-总结</div></div></a></div><div><a href="/2022/10/16/DS_haskell/" title="PFONC-DS 2022 代码"><img class="cover" src="/img/lake.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PFONC-DS 2022 代码</div></div></a></div><div><a href="/2022/10/16/algoa-tp1/" title="ALGOA-TP1"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">ALGOA-TP1</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xin Zhang</div><div class="author-info__description">被教育行业咸鱼</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">9</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">11</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XinZhang0423"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XinZhang0423" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zxin0423@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">转码日记-从入门到菜鸡全记录</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-Programmation-fonctionnelle"><span class="toc-number">1.</span> <span class="toc-text">I. Programmation fonctionnelle:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#definition%E4%BB%A5%E5%8F%8A%E5%87%A0%E4%B8%AA%E4%B8%8D%E6%B8%85%E6%A5%9A%E7%9A%84notions-%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%98%AF%E6%8C%87%E7%94%A8%E6%95%B0%E5%AD%A6%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E5%90%88%E5%8E%BB%E8%A1%A8%E8%BE%BE%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E3%80%82%E4%BE%8B%E5%A6%82%E9%80%92%E5%BD%92%E5%8F%AF%E4%BB%A5%E7%94%A8%E7%9B%B8%E9%82%BB%E9%A1%B9%E7%9A%84%E5%85%B3%E7%B3%BB%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.</span> <span class="toc-text">définition以及几个不清楚的notions :函数式编程是指用数学函数的组合去表达一个算法。例如递归可以用相邻项的关系表示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#II-Construction-de-base-haskell%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91"><span class="toc-number">2.</span> <span class="toc-text">II. Construction de base: haskell基本操作逻辑</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-Composition-%E5%87%BD%E6%95%B0%E5%A4%8D%E5%90%88"><span class="toc-number">3.</span> <span class="toc-text">2.1 Composition: 函数复合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-Evaluation-conditionelle-%E6%9D%A1%E4%BB%B6%E8%B5%8B%E5%80%BC-%E7%94%A8if%E5%AF%B9%E8%B5%8B%E5%80%BC%E6%83%85%E5%86%B5%E8%BF%9B%E8%A1%8C%E8%AF%B4%E6%98%8E%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%92%8C%E5%91%BD%E4%BB%A4%E5%9E%8B%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E5%8C%BA%E5%88%86%E5%BC%80%EF%BC%8Chaskell%E9%87%8C%E5%91%BD%E4%BB%A4%E5%9E%8B%E4%B8%BB%E8%A6%81%E6%98%AFdo-block%E3%80%82"><span class="toc-number">4.</span> <span class="toc-text">2.2 Évaluation conditionelle: 条件赋值 用if对赋值情况进行说明，注意和命令型编程范式区分开，haskell里命令型主要是do block。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-Recursivite-%E7%BB%8F%E5%85%B8%E9%80%92%E5%BD%92%EF%BC%8C%E5%9C%A8%E5%AE%9A%E4%B9%89%E6%97%B6%E8%B0%83%E7%94%A8%E8%87%AA%E5%B7%B1"><span class="toc-number">5.</span> <span class="toc-text">2.3 Récursivité: 经典递归，在定义时调用自己</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-Fonction-Recursive-terminale-%E5%B0%BE%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%8E%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number">6.</span> <span class="toc-text">2.4 Fonction Récursive terminale:尾调用函数与尾递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-Declarations-locales-%E5%B1%80%E9%83%A8%E5%A3%B0%E6%98%8E%EF%BC%8C%E6%B3%A8%E6%84%8F%E5%9C%A8haskell%E9%87%8C%E9%9D%A2%E6%B2%A1%E6%9C%89%E5%8F%98%E9%87%8F%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%9B%A0%E4%B8%BA%E6%89%80%E6%9C%89%E7%9A%84%E9%83%BD%E6%98%AFimmutable%E3%80%82"><span class="toc-number">7.</span> <span class="toc-text">2.5 Déclarations locales: 局部声明，注意在haskell里面没有变量的概念，因为所有的都是immutable。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#III-Types-haskell%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E6%98%AF%E6%9C%80%E8%83%BD%E5%BD%B0%E6%98%BE%E5%85%B6%E8%AF%AD%E6%B3%95%E7%89%B9%E7%82%B9%E7%9A%84%E9%83%A8%E5%88%86"><span class="toc-number">8.</span> <span class="toc-text">III. Types: haskell的数据类型个人认为是最能彰显其语法特点的部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-type-de-base"><span class="toc-number">9.</span> <span class="toc-text">3.1 type de base:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-Type-algebrique-%E4%BB%A3%E6%95%B0%E5%9E%8B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">10.</span> <span class="toc-text">3.2 Type algébrique:代数型数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%81%EF%BC%81-constructeur-de-donnees"><span class="toc-number">10.1.</span> <span class="toc-text">！！ constructeur de données</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%81%EF%BC%81-constructeur%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8Epattern-matching%EF%BC%9A"><span class="toc-number">10.2.</span> <span class="toc-text">！！ constructeur的使用与pattern matching：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-Types-parametres-%EF%BC%9A%E5%90%AB%E5%8F%82%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">3.3 Types paramétrés ：含参类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-Tuple-et-enregistrement-%EF%BC%9A%E5%85%83%E7%BB%84%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E6%80%8E%E4%B9%88%E6%9E%84%E9%80%A0"><span class="toc-number">12.</span> <span class="toc-text">3.4 Tuple et enregistrement ：元组和结构体怎么构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%AA%E5%B1%8F2022-09-20-22-36-47-x2F-Users-x2F-zhangxin-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-%E6%88%AA%E5%B1%8F2022-09-20-22-36-47-png"><span class="toc-number">13.</span> <span class="toc-text">![截屏2022-09-20 22.36.47](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-20 22.36.47.png)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-Types-algebriques-recursifs-%E9%80%92%E5%BD%92%E5%9E%8B%E4%BB%A3%E6%95%B0%E7%BB%93%E6%9E%84%EF%BC%8C%E7%B1%BB%E4%BC%BC%E9%93%BE%E8%A1%A8%E5%92%8C%E6%A0%91%E6%80%8E%E4%B9%88%E6%9E%84%E9%80%A0"><span class="toc-number">14.</span> <span class="toc-text">3.5  Types algébriques récursifs 递归型代数结构，类似链表和树怎么构造</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-6-Liste-%E5%88%97%E8%A1%A8"><span class="toc-number">15.</span> <span class="toc-text">3.6 Liste 列表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-7-Types-generiques"><span class="toc-number">17.</span> <span class="toc-text">3.7 Types génériques</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%AA%E5%B1%8F2022-09-21-19-01-15-x2F-Users-x2F-zhangxin-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-%E6%88%AA%E5%B1%8F2022-09-21-19-01-15-png"><span class="toc-number">18.</span> <span class="toc-text">![截屏2022-09-21 19.01.15](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-21 19.01.15.png)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IV-Fonctions-d%E2%80%99ordre-superieur-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">19.</span> <span class="toc-text">IV. Fonctions d’ordre supérieur:高阶函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Currification-%E2%80%9CCurring%E2%80%9D"><span class="toc-number">20.</span> <span class="toc-text">4.1 Currification “Curring”:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Application-de-fonction-%E4%B8%A4%E7%A7%8D%E7%94%A8%E6%B3%95-%E5%87%BD%E6%95%B0%E8%B5%8B%E5%80%BC"><span class="toc-number">21.</span> <span class="toc-text">4.2 Application de fonction $ 两种用法 函数赋值 ($)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Fonctions-anonymes-Fonctions-%CE%BB"><span class="toc-number">22.</span> <span class="toc-text">4.3 Fonctions anonymes (Fonctions λ)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-Fermetures-Closures-%E9%97%AD%E5%8C%85%EF%BC%9A"><span class="toc-number">23.</span> <span class="toc-text">4.4 Fermetures (Closures) 闭包：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5%E2%80%BC%EF%B8%8F%E2%9A%A0%EF%B8%8Frecursion-sur-les-listes-%E5%BA%94%E7%94%A8%E5%88%B0listes%E7%9A%84%E5%87%BD%E6%95%B0map-filter-foldl-foldr"><span class="toc-number">24.</span> <span class="toc-text">4.5‼️⚠️récursion sur les listes 应用到listes的函数map filter foldl foldr</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E2%80%BC%EF%B8%8F%E7%AC%AC%E5%9B%9B%E7%AB%A0%E6%9C%80%E9%87%8D%E8%A6%81%E9%83%A8%E5%88%86"><span class="toc-number">24.1.</span> <span class="toc-text">‼️第四章最重要部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#V-Methodes-d%E2%80%99evaluation-%E5%87%A0%E7%A7%8D%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95"><span class="toc-number">25.</span> <span class="toc-text">V. Méthodes d’évaluation: 几种赋值方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#VI-Entrees-Sorties-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">26.</span> <span class="toc-text">VI. Entrées, Sorties: 输入输出</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercice"><span class="toc-number">27.</span> <span class="toc-text">exercice:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#et-logique"><span class="toc-number">28.</span> <span class="toc-text">et logique:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Maybe-mfmap-%E7%BB%84%E6%88%90%E4%BA%86foncteur"><span class="toc-number">28.0.1.</span> <span class="toc-text">Maybe + mfmap 组成了foncteur</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prouvoir%E6%93%8D%E4%BD%9C-lift-a-gt-b-gt-m-a-gt-m-b-%E5%B0%86%E4%B8%80%E4%B8%AA%E4%BB%8Ea%E5%88%B0b%E7%9A%84%E5%87%BD%E6%95%B0%E5%8F%98%E6%88%90%E4%BB%8Em-a%E5%88%B0m-b%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">28.0.2.</span> <span class="toc-text">prouvoir操作 lift (a-&gt;b)-&gt;(m a)-&gt;(m b) 将一个从a到b的函数变成从m a到m b的函数</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/DS_haskell/" title="PFONC-DS 2022 代码"><img src="/img/lake.jpg" onerror="this.onerror=null;this.src='/img/codes.jpg'" alt="PFONC-DS 2022 代码"/></a><div class="content"><a class="title" href="/2022/10/16/DS_haskell/" title="PFONC-DS 2022 代码">PFONC-DS 2022 代码</a><time datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/TP1_RSA/" title="PFONC-TP1"><img src="/img/lake.jpg" onerror="this.onerror=null;this.src='/img/codes.jpg'" alt="PFONC-TP1"/></a><div class="content"><a class="title" href="/2022/10/16/TP1_RSA/" title="PFONC-TP1">PFONC-TP1</a><time datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/TP2_demineur/" title="PFONC-TP2"><img src="/img/lake.jpg" onerror="this.onerror=null;this.src='/img/codes.jpg'" alt="PFONC-TP2"/></a><div class="content"><a class="title" href="/2022/10/16/TP2_demineur/" title="PFONC-TP2">PFONC-TP2</a><time datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/TP3_puissance4/" title="PFONC-TP3"><img src="/img/lake.jpg" onerror="this.onerror=null;this.src='/img/codes.jpg'" alt="PFONC-TP3"/></a><div class="content"><a class="title" href="/2022/10/16/TP3_puissance4/" title="PFONC-TP3">PFONC-TP3</a><time datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="python二进制类型与与运算"><img src="/img/ECN.jpg" onerror="this.onerror=null;this.src='/img/codes.jpg'" alt="python二进制类型与与运算"/></a><div class="content"><a class="title" href="/2022/10/16/%E4%BA%8C%E8%BF%9B%E5%88%B6%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/" title="python二进制类型与与运算">python二进制类型与与运算</a><time datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>