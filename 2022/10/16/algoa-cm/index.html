<!DOCTYPE html><html class="hide-aside" lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>ALGOA课堂笔记 | Xin Zhang</title><meta name="keywords" content="ECN,笔记,ALGOA,PYTHON,算法,数据结构"><meta name="author" content="Xin Zhang"><meta name="copyright" content="Xin Zhang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="I. Analyse d’algorithmes: 算法分析学ex经典斐波那契数列，三种写法：两种递归，一种循环，直接的递归时间复杂度非常大，因为重复计算了很多次。 算法分析学包括算法性质分析和复杂度分析： -  -  I.I Prouver des propriétés: 证明算法的性质算法性质主要分成三种：  非功能性性质：Terminaison中止条件（循环中的参数变化等等), Indice">
<meta property="og:type" content="article">
<meta property="og:title" content="ALGOA课堂笔记">
<meta property="og:url" content="http://example.com/2022/10/16/algoa-cm/index.html">
<meta property="og:site_name" content="Xin Zhang">
<meta property="og:description" content="I. Analyse d’algorithmes: 算法分析学ex经典斐波那契数列，三种写法：两种递归，一种循环，直接的递归时间复杂度非常大，因为重复计算了很多次。 算法分析学包括算法性质分析和复杂度分析： -  -  I.I Prouver des propriétés: 证明算法的性质算法性质主要分成三种：  非功能性性质：Terminaison中止条件（循环中的参数变化等等), Indice">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/img/ECN.jpg">
<meta property="article:published_time" content="2022-10-16T20:52:06.000Z">
<meta property="article:modified_time" content="2022-10-16T21:57:56.773Z">
<meta property="article:author" content="Xin Zhang">
<meta property="article:tag" content="ECN">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="ALGOA">
<meta property="article:tag" content="PYTHON">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/ECN.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="http://example.com/2022/10/16/algoa-cm/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'ALGOA课堂笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-10-16 23:57:56'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/ECN.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Xin Zhang</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ALGOA课堂笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-10-16T21:57:56.773Z" title="Updated 2022-10-16 23:57:56">2022-10-16</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ECN-EI2-1/">ECN-EI2|1</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ECN-EI2-1/ALGOA/">ALGOA</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="ALGOA课堂笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="I-Analyse-d’algorithmes-算法分析学"><a href="#I-Analyse-d’algorithmes-算法分析学" class="headerlink" title="I. Analyse d’algorithmes: 算法分析学"></a>I. Analyse d’algorithmes: 算法分析学</h1><p>ex经典斐波那契数列，三种写法：两种递归，一种循环，直接的递归时间复杂度非常大，因为重复计算了很多次。</p>
<p><strong>算法分析学</strong>包括算法<strong>性质分析</strong>和<strong>复杂度分析</strong>：</p>
<p>- </p>
<p>- </p>
<h2 id="I-I-Prouver-des-proprietes-证明算法的性质"><a href="#I-I-Prouver-des-proprietes-证明算法的性质" class="headerlink" title="I.I Prouver des propriétés: 证明算法的性质"></a>I.I Prouver des propriétés: 证明算法的性质</h2><p>算法性质主要分成三种：</p>
<ul>
<li>非功能性性质：Terminaison中止条件（循环中的参数变化等等), Indices de tableaux,Poiteur,<strong>débordement de capacité</strong>内存溢出</li>
<li>功能性性质：功能上的性质，算法要实现的目标</li>
<li>性能：</li>
</ul>
<p>因为对一个算法做测试是不够详尽的（non-exhaustif），所以需要用数学方法证明算法的性质，算法证明的标准化方法（méthodes formelles）</p>
<h3 id="1-Proprietes-non-fonctionnelles-非功能性性质"><a href="#1-Proprietes-non-fonctionnelles-非功能性性质" class="headerlink" title="1.Propriétés non-fonctionnelles:非功能性性质"></a>1.Propriétés non-fonctionnelles:非功能性性质</h3><p>Terminaison des algorithmes算法的中止条件，引入bien fondée 良基</p>
<p>wiki：在数学中，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A1%9E_(%E6%95%B8%E5%AD%B8)">类</a> <em>X</em> 上的一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%85%83%E5%85%B3%E7%B3%BB">二元关系</a> <em>R</em> 被称为是<strong>良基的</strong>，当且仅当所有 <em>X</em> 的非空子集都有一个 <em>R</em>-<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%9E%81%E5%B0%8F%E5%85%83">极小元</a>；就是说，对 <em>X</em> 的每一个非空子集 <em>S</em>，存在一个 <em>S</em> 中的元素 <em>m</em> 使得对于所有 <em>S</em>中的 <em>s</em>，二元组 (<em>s</em>,<em>m</em>) 都不在 <em>R</em> 中。</p>
<p>我的理解：在一个集合上一个二元关系是良基的，指在该集合上，不存在无限递减的序列。</p>
<p>而一个集合是良基的，只需存在一个良基的二元关系。</p>
<p>证明一个算法是可终止的，只需证明1.算法循环或者递归的算法在一个良基集合中，2.且每一次迭代后，参数是严格递减的：</p>
<p>![image-20220908222038100](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220908222038100.png)</p>
<h3 id="2-Proprietes-fonctionnelles-功能性性质"><a href="#2-Proprietes-fonctionnelles-功能性性质" class="headerlink" title="2.Propriétés fonctionnelles: 功能性性质"></a>2.Propriétés fonctionnelles: 功能性性质</h3><h4 id="PF-Exercice-1-correction-fonctionnelle-du-tri-par-insertion-以插值算法为例，研究算法的功能性质"><a href="#PF-Exercice-1-correction-fonctionnelle-du-tri-par-insertion-以插值算法为例，研究算法的功能性质" class="headerlink" title="PF_Exercice 1 : correction fonctionnelle du tri par insertion 以插值算法为例，研究算法的功能性质"></a>PF_Exercice 1 : correction fonctionnelle du tri par insertion 以插值算法为例，研究算法的功能性质</h4><p>插值算法简介：</p>
<p>分成两部分，一是从第二个元素开始一次把它和前面元素比较，插到合适的位置。二是，写出插值函数，与前面的值做判断获得</p>
<p>待写：</p>
<h4 id="PF-Exercice-2-algorithme-d’Euclide-欧几里得算法"><a href="#PF-Exercice-2-algorithme-d’Euclide-欧几里得算法" class="headerlink" title="PF_Exercice 2 : algorithme d’Euclide 欧几里得算法"></a>PF_Exercice 2 : algorithme d’Euclide 欧几里得算法</h4><p>待写：</p>
<h3 id="3-Performances"><a href="#3-Performances" class="headerlink" title="3.Performances:"></a>3.Performances:</h3><p>常见的两种性质：</p>
<ul>
<li><p>Invariants de boucles循环不变量 Propriétés inductives归纳性性质：需要用归纳法来证明par induction&#x2F;référence。在第k次循环时算法所体现出来的性质，从功能和内部参数两个角度去思考。</p>
</li>
<li><p>Précondition-Postcondition: assume-garantee在满足前条件前提下（sous réserve de），算法实现后条件</p>
</li>
</ul>
<h3 id="4-Invariant-et-probleme-insoluble：（没有算法可以来解决的问题）"><a href="#4-Invariant-et-probleme-insoluble：（没有算法可以来解决的问题）" class="headerlink" title="4. Invariant et problème insoluble：（没有算法可以来解决的问题）"></a>4. Invariant et problème insoluble：（没有算法可以来解决的问题）</h3><p>利用循环不变量证明不可解问题：1.选择一个能被任意假定的循环算法满足的不变量。2.这个不变量不满足最后的结果。</p>
<h4 id="Insoluble-Exercice：dominos覆盖棋盘问题："><a href="#Insoluble-Exercice：dominos覆盖棋盘问题：" class="headerlink" title="Insoluble_Exercice：dominos覆盖棋盘问题："></a>Insoluble_Exercice：dominos覆盖棋盘问题：</h4><p>待写</p>
<h3 id="5-Preuve-automatique-et-indecidabilite-决定性问题-sat问题"><a href="#5-Preuve-automatique-et-indecidabilite-决定性问题-sat问题" class="headerlink" title="5. Preuve automatique et indécidabilité: 决定性问题 sat问题"></a>5. Preuve automatique et indécidabilité: 决定性问题 sat问题</h3><p>在计算理论中问题的种类分为决定性问题problème de décision，功能性问题和最佳化问题：</p>
<p>分别回答的是：是与否（判定行问题），有哪些，哪个是最好。</p>
<p>在研究复杂度的领域中决定性问题按照不可解度（图灵度）进行分类。</p>
<p>不存在可以解决该问题的算法，则该算法称为不可解问题indécidable</p>
<p>équation diophantienne </p>
<h2 id="I-II-Complexite-复杂度："><a href="#I-II-Complexite-复杂度：" class="headerlink" title="I.II Complexité:复杂度："></a>I.II Complexité:复杂度：</h2><p>算法的复杂是用来考验算法的表现（preformance），一个问题的复杂度是由最优算法决定的，有两种角度计算</p>
<p>计算算法时间复杂度，和计算使用的最大内存。</p>
<p>复杂度与：</p>
<p>输入大小taille de l’entrée，最优或最差的情况meuilleur cas pire cas，平均情况cas moyen(espérance)</p>
<p>以及使用的模型，图灵机或者ram</p>
<h3 id="1-Machine-de-Turing-图灵机："><a href="#1-Machine-de-Turing-图灵机：" class="headerlink" title="1.Machine de Turing 图灵机："></a>1.Machine de Turing 图灵机：</h3><h4 id="1-1传统图灵机machine-de-turing-determinate"><a href="#1-1传统图灵机machine-de-turing-determinate" class="headerlink" title="1.1传统图灵机machine de turing determinate"></a>1.1传统图灵机machine de turing determinate</h4><p>包括：</p>
<ul>
<li><p>记录当前指令数的etat</p>
</li>
<li><p>无穷长度的tableau组成的memoire，包含各种symbole组成的alphabet</p>
</li>
<li><p>一个tete de lecture读取头，cur代表当前的指向的case</p>
</li>
<li><p>有一个输入值entree</p>
<p>非常类似上个学期学的。注意每个etat对应一个instruction，每个instruction要包含entree的各种可能。</p>
<h4 id="MT-Exemple-计算补码："><a href="#MT-Exemple-计算补码：" class="headerlink" title="MT_Exemple:计算补码："></a>MT_Exemple:计算补码：</h4></li>
</ul>
<p>![截屏2022-09-13 21.45.29](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-13 21.45.29.png)</p>
<h4 id="MT-Exercice-判断一个词是不是palindrome回文"><a href="#MT-Exercice-判断一个词是不是palindrome回文" class="headerlink" title="MT_Exercice:判断一个词是不是palindrome回文"></a>MT_Exercice:判断一个词是不是palindrome回文</h4><p>待插</p>
<p>![截屏2022-09-13 21.55.07](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-13 21.55.07.png)</p>
<p>在图灵机模型下，</p>
<p>![截屏2022-09-13 21.57.24](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-13 21.57.24.png)</p>
<blockquote>
<p>常见的决定性问题的复杂度分类：</p>
<p>多项式时间（线性），多项式空间（rush），指数时间（围棋），指数空间</p>
<p>![截屏2022-09-13 21.59.58](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-13 21.59.58.png)</p>
</blockquote>
<ul>
<li><p>经典问题：sat问题</p>
<p>![截屏2022-09-13 22.01.53](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-13 22.01.53.png)</p>
</li>
</ul>
<p>exemple：如何将八皇后问题改写为sat问题：</p>
<p>待插</p>
<h4 id="1-2-machine-de-turing-non-determiste"><a href="#1-2-machine-de-turing-non-determiste" class="headerlink" title="1.2 machine de turing non-determiste:"></a>1.2 machine de turing non-determiste:</h4><p>背景：解决背包问题，sat问题，ilp问题等，传统图灵机算法需要指数时间，这类问题好验证不好证明。</p>
<p>工作原理：在输入的值不同情况下并行执行同样的指令，从而同时对多个可能进行验证，快速找到解，或证明解不存在。</p>
<p>非决定性图灵机能以多项式时间解决的问题</p>
<p>克雷数学研究所千禧年七大数学问题之一：p&#x3D;np</p>
<ul>
<li><p>Borne inférieur et complétude: 下界与完备性 </p>
<p> 如果我们能将任意属于c难度问题的实例转化成一个p问题的实例，且转化尽在多项式时间内完成，则称p是c-difficle的。如果说p属于c，则称p是c-complet的。完全问题是该难度类中最难的一类问题。</p>
</li>
</ul>
<p>sat就是np完全问题</p>
<h4 id="MTND-Exercice-证明ilp是np完全问题："><a href="#MTND-Exercice-证明ilp是np完全问题：" class="headerlink" title="MTND_Exercice:证明ilp是np完全问题："></a>MTND_Exercice:证明ilp是np完全问题：</h4><h3 id="2-ram："><a href="#2-ram：" class="headerlink" title="2. ram："></a>2. ram：</h3><h3 id="3-complexite-asymptotique：当输入的n趋于无穷时的复杂度。渐进复杂度"><a href="#3-complexite-asymptotique：当输入的n趋于无穷时的复杂度。渐进复杂度" class="headerlink" title="3.complexite asymptotique：当输入的n趋于无穷时的复杂度。渐进复杂度"></a>3.complexite asymptotique：当输入的n趋于无穷时的复杂度。渐进复杂度</h3><p>通常有三种比较大小的方式：</p>
<ol>
<li>Domination：O,$\Omega$,$\Theta$</li>
<li>Négligeabilité: o,$\omega$,1</li>
</ol>
<p>计算复杂度其他的项都视为常数k，然后用大O表示法，直接忽略掉大O</p>
<p>![截屏2022-09-13 22.22.46](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-13 22.22.46.png)</p>
<p>最坏情况计算算法复杂度，</p>
<p>最坏情况计算递归算法复杂度</p>
<p>练习：利用指示性随机变量计算算法平均复杂度-构造随机变量</p>
<h4 id="CPC-Exercice1-计算各种复杂度的nombre-d’inversion："><a href="#CPC-Exercice1-计算各种复杂度的nombre-d’inversion：" class="headerlink" title="CPC_Exercice1:计算各种复杂度的nombre d’inversion："></a>CPC_Exercice1:计算各种复杂度的nombre d’inversion：</h4><p>待插</p>
<h4 id="4-Complexite-pire-cas-des-algorithmes-recursifs"><a href="#4-Complexite-pire-cas-des-algorithmes-recursifs" class="headerlink" title="4. Complexité pire cas des algorithmes récursifs :"></a>4. Complexité pire cas des algorithmes récursifs :</h4><p>利用数学归纳法来求递归算法的复杂度，用相邻两项的递推公式来求。</p>
<h4 id="CPC-Exercice2-证明斐波那契数列复杂度"><a href="#CPC-Exercice2-证明斐波那契数列复杂度" class="headerlink" title="CPC_Exercice2:证明斐波那契数列复杂度"></a>CPC_Exercice2:证明斐波那契数列复杂度</h4><p>待插</p>
<h4 id="5-complexite-moyenne平均复杂度："><a href="#5-complexite-moyenne平均复杂度：" class="headerlink" title="5.complexité moyenne平均复杂度："></a>5.complexité moyenne平均复杂度：</h4><ul>
<li><p>为输入值设置概率分布，</p>
</li>
<li><p>利用计算概率分布的期望来计算复杂度</p>
<p>平均复杂度计算需要概率分布，并计算复杂的期望，因此引入指示性随机变量（variable aléatoire indicatrice),</p>
</li>
</ul>
<p>![截屏2022-09-14 10.44.22](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-14 10.44.22.png)</p>
<h4 id="CP-Exercice1"><a href="#CP-Exercice1" class="headerlink" title="CP_Exercice1:"></a>CP_Exercice1:</h4><p>学会构造好的随机变量</p>
<p>待插</p>
<h4 id="CP-Exercice2"><a href="#CP-Exercice2" class="headerlink" title="CP_Exercice2:"></a>CP_Exercice2:</h4><h4 id="CP-Exercice3"><a href="#CP-Exercice3" class="headerlink" title="CP_Exercice3:"></a>CP_Exercice3:</h4><h3 id="6-algoritme-probabiliste-在执行传统算法前随机混合输入。"><a href="#6-algoritme-probabiliste-在执行传统算法前随机混合输入。" class="headerlink" title="6. algoritme probabiliste: 在执行传统算法前随机混合输入。"></a>6. algoritme probabiliste: 在执行传统算法前随机混合输入。</h3><p>没理解，待查找信息</p>
<h4 id="Exemple-Monte-Carlo-Las-Vegas"><a href="#Exemple-Monte-Carlo-Las-Vegas" class="headerlink" title="Exemple:Monte-Carlo,Las Vegas"></a>Exemple:Monte-Carlo,Las Vegas</h4><p>一大段垮掉，不太懂这里什么意思：</p>
<p>![截屏2022-09-14 10.51.34](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-14 10.51.34.png)</p>
<h4 id="Algo-Exercice1-l利用biais-random构造伯努利分布，也是构造指示性随机变量来求，平均复杂度和求概率性算法复杂度都是如此。因为本身平均复杂的的概念（需要理解一下？）"><a href="#Algo-Exercice1-l利用biais-random构造伯努利分布，也是构造指示性随机变量来求，平均复杂度和求概率性算法复杂度都是如此。因为本身平均复杂的的概念（需要理解一下？）" class="headerlink" title="Algo_Exercice1:l利用biais_random构造伯努利分布，也是构造指示性随机变量来求，平均复杂度和求概率性算法复杂度都是如此。因为本身平均复杂的的概念（需要理解一下？）"></a>Algo_Exercice1:l利用biais_random构造伯努利分布，也是构造指示性随机变量来求，平均复杂度和求概率性算法复杂度都是如此。因为本身平均复杂的的概念（需要理解一下？）</h4><p>待插</p>
<h4 id="Algo-Exercice2-利用递归证明排序，并求复杂度"><a href="#Algo-Exercice2-利用递归证明排序，并求复杂度" class="headerlink" title="Algo_Exercice2:利用递归证明排序，并求复杂度"></a>Algo_Exercice2:利用递归证明排序，并求复杂度</h4><p>待插</p>
<h1 id="II-Conception-d’algorithmes-几大算法设计理念"><a href="#II-Conception-d’algorithmes-几大算法设计理念" class="headerlink" title="II. Conception d’algorithmes:几大算法设计理念"></a>II. Conception d’algorithmes:几大算法设计理念</h1><h3 id="II-I-Enumeration-exhaustive穷举法"><a href="#II-I-Enumeration-exhaustive穷举法" class="headerlink" title="II.I Énumération exhaustive穷举法"></a>II.I Énumération exhaustive穷举法</h3><p>relaxation P’ : un ensemble fini de solution。通常情况下p‘要比p解更多，我们可以先用一些基本条件去限制这个p’例如对称性symétrie，旋转rotation和镜像réflexion等等。</p>
<h4 id="1-carre-magique"><a href="#1-carre-magique" class="headerlink" title="1.carré magique:"></a>1.carré magique:</h4><p>在n*n的正方形格子里，放置数字使得每一行每一列每一对角线的和为定值。</p>
<p>初略分析：这个定值为n*(n^2+1)&#x2F;2</p>
<p>基本实现：</p>
<p>1.写一个判断函数，来判断carre是否满足条件</p>
<p>2.写一个打印函数，将满足条件的打印出来</p>
<p>3.写一个遍历所有数，用一个布尔型列表存储每个数字是否被使用过了，每次遍历时只需要判断是否使用过即可，不需要更多的判断，在填完后判断是否符合要求。</p>
<p>![截屏2022-09-25 18.46.54](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-25 18.46.54.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line"><span class="comment">#测试一行的和是否为特定值</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_list</span>(<span class="params">L</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(L)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(L) == n * (n * n + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#把每一行列（用矩阵转置解决列的问题）和对角线存到一个大列表了，用map应用测试行的，</span></span><br><span class="line"><span class="comment">#熟悉zip(),zip(*)的操作，尤其是应用于矩阵： </span></span><br><span class="line">*xx是解包操作，将一个iterable解包，例如[a,b,c]解成a,b,c</span><br><span class="line">A=[[a,b],[c,d]]</span><br><span class="line"><span class="built_in">zip</span>(*A)</span><br><span class="line"><span class="comment">#本来应该是对里面每一个都是true的，这里用了reduce(operator.__and__,B,True)来判断一个布尔型的列表是否全是true，省着写循环了，学着点！</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">test_carre</span>(<span class="params">C</span>):</span><br><span class="line">    Ct = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="built_in">list</span>, <span class="built_in">zip</span>(*C))) <span class="comment"># transpose la matrice</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># diagonales</span></span><br><span class="line">    d1 = [C[i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    d2 = [C[<span class="built_in">len</span>(C) - <span class="number">1</span> -i][i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line"></span><br><span class="line">    L = C + Ct + [d1] + [d2]</span><br><span class="line">    B = <span class="built_in">map</span>(test_list, L)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> reduce(operator.__and__, B, <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">print_carre</span>(<span class="params">C</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(C)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;C[i][j]&#125;</span> &quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">#对每一个格子k，都从1到n^2遍历，填入以前没填过的，因此需要t来记录是否填过。最后重制</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">carre</span>(<span class="params">C, T, k</span>):</span><br><span class="line">    <span class="comment"># k est le numéro de la case que je souhaite remplir</span></span><br><span class="line">    <span class="keyword">if</span> k == n*n: </span><br><span class="line">        <span class="keyword">if</span> test_carre(C):</span><br><span class="line">            print_carre(C)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># i est le nombre que j&#x27;essaie de mettre dans la case numéro k</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, n*n+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> T[i]:</span><br><span class="line">                T[i] = <span class="literal">True</span></span><br><span class="line">                C[k // n][k % n] = i</span><br><span class="line">                carre(C, T, k + <span class="number">1</span>)</span><br><span class="line">                T[i] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">n = <span class="number">4</span></span><br><span class="line">C = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]  </span><br><span class="line">T = [<span class="literal">False</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n*n+<span class="number">1</span>)]</span><br><span class="line">carre(C, T, <span class="number">0</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="课后练习：用枚举法写八皇后问题，sat问题等等"><a href="#课后练习：用枚举法写八皇后问题，sat问题等等" class="headerlink" title="课后练习：用枚举法写八皇后问题，sat问题等等"></a>课后练习：用枚举法写八皇后问题，sat问题等等</h2><h3 id="II-II-Backtracking回溯法"><a href="#II-II-Backtracking回溯法" class="headerlink" title="II.II :Backtracking回溯法"></a>II.II :Backtracking回溯法</h3><p>回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。 但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p>
<p>类似遍历树结构，所以是递归的</p>
<p>八皇后问题，和走马问题：可以自己写一遍用python</p>
<p>![截屏2022-09-25 20.33.51](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-25 20.33.51.png)</p>
<p>枚举和回溯的总结：</p>
<p>主函数一般有一个记录列表L，一个记录当前次数k,一个当前的参数用于输入下次判断，</p>
<ol>
<li>先写一个结束条件，枚举和回溯的主要区别就在这里，</li>
</ol>
<ul>
<li><strong>枚举</strong>是当前次数为某个值时，全部填完或者列完，执行一次判断，如果判断为真就返回否则继续。</li>
<li><strong>回溯</strong>是当前为次数为某个值时，说明刚好完全深度遍历树，达到最深的情况，直接返回不需要判断</li>
</ul>
<ol start="2">
<li>再写一个for 循环，区别：</li>
</ol>
<ul>
<li><p><strong>枚举</strong>，用一个参数记录上一次的，判断这一次和上一次不一样就可以，无需要提前判断，只需要最后一次判断就行</p>
</li>
<li><p><strong>回溯</strong>，在每次执行for循环时做判断，下一步是否合法，或者从当前情况直接推断出下一步合法的范围从中选择。一旦不合法，就直接复原参数重新遍历</p>
</li>
</ul>
<p>棋盘类问题数据类型总结：</p>
<ol>
<li>用一个列表套列表来记录棋盘上的信息</li>
<li>用元组列表记录坐标值</li>
<li>用printb函数for for print，打印棋盘</li>
<li>用一个布尔型列表来记录一个值是否被用过。</li>
</ol>
<p>回溯法也是枚举中间会加上判断，不会完全枚举所有情况，而是过程中加上判断，如果不行就退回前一步执行。本质上形成一个树，实现对树的深度遍历。</p>
<p>枚举和回溯的本质区别在于for中止条件的判断位置，枚举法是要在全局最后做判断，回溯法是要在每一次开始前做判断：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#我觉得我又行了，写了几个以后发现还挺简单的哈哈哈！！！</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">testQ</span>(<span class="params">L,i,j</span>):</span><br><span class="line">    <span class="keyword">for</span> (k,l) <span class="keyword">in</span>  L:</span><br><span class="line">        <span class="keyword">if</span> k == i <span class="keyword">or</span> l == j <span class="keyword">or</span> <span class="built_in">abs</span>(k-i) == <span class="built_in">abs</span> (l-j):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printQ</span>(<span class="params">L</span>):</span><br><span class="line">    <span class="built_in">print</span>(L)</span><br><span class="line">    n = <span class="built_in">len</span>(L)</span><br><span class="line">    </span><br><span class="line">    B = [[<span class="string">&#x27;O&#x27;</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (i,j) <span class="keyword">in</span> L:</span><br><span class="line">        B[i][j]=<span class="string">&#x27;Q&#x27;</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;B[i][j]&#125;</span>&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">queen</span>(<span class="params">L,i,n</span>):</span><br><span class="line">    <span class="keyword">if</span> i == n :</span><br><span class="line">        printQ(L)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> testQ(L,i,j):</span><br><span class="line">                L2 = L[:]</span><br><span class="line">                L2.append((i,j))</span><br><span class="line">                queen(L2,i+<span class="number">1</span>,n)</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L = []</span><br><span class="line">queen(L,<span class="number">0</span>,<span class="number">4</span>)</span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#voyage du cavalier:</span></span><br><span class="line"><span class="comment">#马走日问题：</span></span><br><span class="line"><span class="comment">#基本数据类型分析：</span></span><br><span class="line"><span class="comment">#用一个元组列表来存每一次走的位置，然后写一个函数，输入已经走过的位置列表，输出一个可以走的位置列表。</span></span><br><span class="line"><span class="comment">#主函数是对于遍历任意可以走的位置列表，走下一步，然后知道所有位置都走完了就退出</span></span><br><span class="line"><span class="comment">#je matrise 基本上可以独立写出来这种题了哈哈！</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">availK</span>(<span class="params">B,i,j</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(B)</span><br><span class="line">    deps = [(<span class="number">2</span>,<span class="number">1</span>), (-<span class="number">2</span>,<span class="number">1</span>), (<span class="number">2</span>, -<span class="number">1</span>), (-<span class="number">2</span> , -<span class="number">1</span>), (<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, -<span class="number">2</span>), (-<span class="number">1</span>, <span class="number">2</span>), (-<span class="number">1</span>, -<span class="number">2</span>)]</span><br><span class="line">    L = []</span><br><span class="line">    <span class="keyword">for</span> (x, y) <span class="keyword">in</span> deps:</span><br><span class="line">        <span class="keyword">if</span> i+x &gt;= <span class="number">0</span> <span class="keyword">and</span> i + x &lt; n <span class="keyword">and</span> j + y &gt;= <span class="number">0</span> <span class="keyword">and</span> j + y &lt; n <span class="keyword">and</span> B[i + x][j + y] == <span class="number">0</span>:</span><br><span class="line">            L.append((i+x, j+y))</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">printB</span>(<span class="params">B</span>):</span><br><span class="line">    n = <span class="built_in">len</span> (B)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;<span class="subst">&#123;B[i][j]&#125;</span>&quot;</span>,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>()</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">knight</span>(<span class="params">B,i,j,k</span>):</span><br><span class="line">    n=<span class="built_in">len</span>(B)</span><br><span class="line">    <span class="keyword">if</span> k == n*n + <span class="number">1</span>:</span><br><span class="line">        printB(B) </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        <span class="keyword">for</span> (p,q) <span class="keyword">in</span> availK(B,i,j) :</span><br><span class="line">            B[p][q]=k</span><br><span class="line">            knight(B,p,q,k+<span class="number">1</span>)</span><br><span class="line">            B[p][q]=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">n=<span class="number">6</span>           </span><br><span class="line">B=[[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]<span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">B[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">knight(B,<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>)          </span><br><span class="line">       </span><br><span class="line">            </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="II-IV-Diviser-pour-regner分治法"><a href="#II-IV-Diviser-pour-regner分治法" class="headerlink" title="II.IV:Diviser pour régner分治法"></a>II.IV:Diviser pour régner分治法</h3><p>![截屏2022-09-25 21.45.46](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-25 21.45.46.png)</p>
<p>把一个问题化解成子问题然后递归的解决。递归地解决子问题然后合并：</p>
<h4 id="1-归并排序理解分治法——二路归并："><a href="#1-归并排序理解分治法——二路归并：" class="headerlink" title="1.归并排序理解分治法——二路归并："></a>1.归并排序理解分治法——二路归并：</h4><p>归并排序是递归算法的一个实例，这个算法中基本的操作是</p>
<p><strong>合并两个已排序的数组</strong>，<strong>取两个输入数组 A 和 B</strong>，<strong>一个输出数组 C</strong>，<strong>以及三个计数器 i、j、k</strong>，它们初始位置置于对应数组的开始端。<br><strong>A[i] 和 B[j] 中较小者拷贝到 C 中的下一个位置，相关计数器向前推进一步。</strong>当两个输入数组有一个用完时候，则将另外一个数组中剩余部分拷贝到 C 中。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line">    <span class="string">&quot;&quot;&quot;_summary_：因为是自己亲手写的，没有查任何资料，所以可以总结出很多分治法心得，首先分成几个部分，每个部分分别使用同一个结构执行。</span></span><br><span class="line"><span class="string">    1.递归可以从两个尺度去理解和debug，一个是执行层，一个是总的分治法部分</span></span><br><span class="line"><span class="string">    2.中间递归部分很好写，主要是执行层的判断和统一结构需要满足各种维度的调用</span></span><br><span class="line"><span class="string">    3.首先要明确执行层，即执行层的判断要看最开始的if，这里是当d+1=f的时候执行后面的操作，也就是要相邻，因此需要在前面if 处就确定执行层，可以这样理解：当f=d时后无了，所以上一个执行的d和f就是相邻</span></span><br><span class="line"><span class="string">    4.总的分治法部分和后面的统一结构想清楚即可</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">merge_sort</span>(<span class="params">A,d,f</span>):</span><br><span class="line">    <span class="keyword">if</span> f - d &gt; <span class="number">0</span> :</span><br><span class="line">    <span class="comment">#其实是这里判断什么时候开始排，什么时候不往下调用了，这里f-d=1时不往下调用了，所以这种递归的看f-d&gt;1为结束条件，说明mergesort此时dm和mf都差1时就停止调用往下执行。</span></span><br><span class="line">    <span class="comment">#这是一个看递归的技巧，直接去找结束条件和最后的条件即可，中间怎么搞不用管。</span></span><br><span class="line">    <span class="comment">#这里结束条件就是此时d=m,m+1=f,而最后条件就是已经排好了两个有序列表的融合。</span></span><br><span class="line">    <span class="comment">#有序列表的融合可以背下来，很简单！</span></span><br><span class="line">    <span class="comment">#将现在的分成两部分</span></span><br><span class="line">        m = <span class="built_in">int</span> ((d+f)/<span class="number">2</span>)</span><br><span class="line">    <span class="comment">#从最后的视角去理解就是分别排左边和右边的部分：</span></span><br><span class="line">        merge_sort(A,d,m)</span><br><span class="line">        merge_sort(A,m+<span class="number">1</span>,f)</span><br><span class="line">        B= A.copy()</span><br><span class="line">    <span class="comment">#将两个有序列表混合，需要三个参数，和复制一个新的列表</span></span><br><span class="line">        i = d</span><br><span class="line">        j = m+<span class="number">1</span></span><br><span class="line">        k = d</span><br><span class="line">        <span class="keyword">while</span> i &lt; m + <span class="number">1</span> <span class="keyword">or</span> j &lt; f + <span class="number">1</span> :</span><br><span class="line">            <span class="keyword">if</span> i == m + <span class="number">1</span> :</span><br><span class="line">                A[k]= B[j]</span><br><span class="line">                j+= <span class="number">1</span>  </span><br><span class="line">            <span class="keyword">elif</span> j == f + <span class="number">1</span>:</span><br><span class="line">                A[k]= B[i]</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> B[i] &lt; B[j] :</span><br><span class="line">                    A[k]= B[i]</span><br><span class="line">                    i+= <span class="number">1</span></span><br><span class="line">                <span class="keyword">elif</span> B[i] &gt; B[j] :</span><br><span class="line">                    A[k]= B[j]</span><br><span class="line">                    j+= <span class="number">1</span></span><br><span class="line">            k+= <span class="number">1</span>          </span><br><span class="line">n= <span class="number">15</span></span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">range</span>(n))</span><br><span class="line">shuffle(L)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">merge_sort(L,<span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(L) m = <span class="built_in">int</span> ((d+f)/<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<h4 id="2-二分查找-recherche-dichotomique："><a href="#2-二分查找-recherche-dichotomique：" class="headerlink" title="2. 二分查找 recherche dichotomique："></a>2. 二分查找 recherche dichotomique：</h4><p>像这种二分递归需要一直除以二的，最后的递归条件是固定的：</p>
<p>分析：当m &#x3D; f + d &#x2F;&#x2F; 2时，d从0逐渐增加，f从最后一项逐渐减少</p>
<p>如果是 d ,m    m+1,f. 则 当f-d&#x3D;1时， 此次为 d &#x3D; m &#x3D; f - 1, 下一次为 d &#x3D; f &#x3D; m，所以需要在最开始加if f-d&gt;0 作为连续递归条件，这样保证递归停止时，d和f刚好相邻，此时m刚好等于d，m+1等于f </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dichitomique</span>(<span class="params">L,x,d,f</span>): </span><br><span class="line">  <span class="keyword">if</span> f - d &gt;<span class="number">0</span> :</span><br><span class="line">    m = ( f + d ) // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> L[m] == x :</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">elif</span> L[m] &gt; x :</span><br><span class="line">      	<span class="keyword">return</span> dichitomique(L,x,d,m)</span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">      	<span class="keyword">return</span> dichitomique(L,x,m+<span class="number">1</span>,f)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> (L[d]==x) </span><br></pre></td></tr></table></figure>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#返回一个元素出现的次数</span></span><br><span class="line"><span class="comment">#通过返回最小的indice和最大的indice计算长度</span></span><br><span class="line"><span class="comment">#和二分查找一样，只不过多了一个往两边移动的条件1.(L[m-1] == x and d &lt; m)，2.(L[m+1]==x and m &lt; f) d&lt;m 和m&gt;f放置移出去</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">fst</span>(<span class="params">L,x,d,f</span>):</span><br><span class="line">    <span class="keyword">if</span> f - d &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> L[d]== x:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        m = (f+d)//<span class="number">2</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> x &lt; L[m] <span class="keyword">or</span> (L[m-<span class="number">1</span>] == x <span class="keyword">and</span> d &lt; m):</span><br><span class="line">            <span class="keyword">return</span> fst(L,x,d,m)</span><br><span class="line">        <span class="keyword">elif</span> x &gt; L[m] :</span><br><span class="line">            <span class="keyword">return</span> fst(L,x,m+<span class="number">1</span>,f)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">lst</span>(<span class="params">L,x,d,f</span>):</span><br><span class="line">    <span class="keyword">if</span> f - d &lt;=<span class="number">0</span>:</span><br><span class="line">        <span class="keyword">if</span> L[d]==x:</span><br><span class="line">            <span class="keyword">return</span> d</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        m = (f+d)//<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> L[m] &lt; x <span class="keyword">or</span> (L[m+<span class="number">1</span>]==x <span class="keyword">and</span> m &lt; f):</span><br><span class="line">            <span class="keyword">return</span> lst(L,x,m+<span class="number">1</span>,f)</span><br><span class="line">        <span class="keyword">elif</span> L[m] &gt;x:</span><br><span class="line">            <span class="keyword">return</span> lst(L,x,d,m)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> m</span><br><span class="line">        </span><br><span class="line">L = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">px = fst(L, x, <span class="number">0</span>, <span class="built_in">len</span>(L) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;première occurence de <span class="subst">&#123;x&#125;</span> dans <span class="subst">&#123;L&#125;</span>: <span class="subst">&#123;px&#125;</span>&#x27;</span>)</span><br><span class="line">dx = lst(L, x, <span class="number">0</span>, <span class="built_in">len</span>(L) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;dernière occurence de <span class="subst">&#123;x&#125;</span> dans <span class="subst">&#123;L&#125;</span>: <span class="subst">&#123;dx&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;nombre d\&#x27;occurences de <span class="subst">&#123;x&#125;</span> dans <span class="subst">&#123;L&#125;</span>: <span class="subst">&#123;dx - px + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>



<h4 id="3-在有洞的棋盘上铺牌pavage-de-trominos"><a href="#3-在有洞的棋盘上铺牌pavage-de-trominos" class="headerlink" title="3. 在有洞的棋盘上铺牌pavage de trominos"></a>3. 在有洞的棋盘上铺牌pavage de trominos</h4><p>1.a&#x3D;1,b&#x3D;2,k&#x3D;0	<br>  T(n)&#x3D;$\Theta(log_{2}n)$</p>
<ol start="3">
<li>每个tromino，由放置的左上角的坐标和缺少的坐标表示。</li>
</ol>
<p>N&#x3D;2^n</p>
<p>N^2</p>
<p>a&#x3D;4,b&#x3D;2,k&#x3D;0</p>
<p>n^2</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#用矩阵来存棋盘</span></span><br><span class="line"><span class="comment">#用数字来表示填入triminos</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="comment">#dx，dy记录triminos左上角的值，i，j记录trou的坐标，strategy：这个方格内除了trou以外都传入数字k：</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">addT</span>(<span class="params">A,dx,dy,i,j,k</span>):</span><br><span class="line">    <span class="keyword">for</span> a <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        x=dx+a</span><br><span class="line">        <span class="keyword">for</span> b <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            y=dy+b</span><br><span class="line">            <span class="keyword">if</span> x!=i <span class="keyword">or</span> y!=j:</span><br><span class="line">                A[x][y]=k</span><br><span class="line"></span><br><span class="line"><span class="comment">#dx,fx,dy,fy记录研究的方块的四角坐标，i,j记录trou的坐标，k记录填的次数：              </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">triminos</span>(<span class="params">A,dx,fx,dy,fy,i,j,k</span>):</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#第一步写递归的停止条件，只剩下四个格的时候：</span></span><br><span class="line">    <span class="keyword">if</span> fx - dx == <span class="number">1</span> :</span><br><span class="line">        addT(A,dx,dy,i,j,k)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        mx = (dx+fx+<span class="number">1</span> )  //<span class="number">2</span></span><br><span class="line">        my = (dy+fy+<span class="number">1</span>)   //<span class="number">2</span></span><br><span class="line">        <span class="comment">#每次调用自动分成四部分，分别对每个部分使用trominos，当ij在里面时，执行if里的否则默认添加trou到a，b</span></span><br><span class="line">        <span class="comment">#左上角：</span></span><br><span class="line">        a = mx -<span class="number">1</span></span><br><span class="line">        b = my -<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; mx <span class="keyword">and</span> j &lt; my:</span><br><span class="line">            addT(A,mx-<span class="number">1</span>,my-<span class="number">1</span>,a,b,k)</span><br><span class="line">        </span><br><span class="line">            a=i</span><br><span class="line">            b=j</span><br><span class="line">        triminos(A,dx,mx-<span class="number">1</span>,dy,my-<span class="number">1</span>,a,b,k+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#左下角；</span></span><br><span class="line">        a = mx-<span class="number">1</span></span><br><span class="line">        b = my</span><br><span class="line">        <span class="keyword">if</span> i &lt; mx <span class="keyword">and</span> j &gt;my-<span class="number">1</span>:</span><br><span class="line">            addT(A,mx-<span class="number">1</span>,my-<span class="number">1</span>,a,b,k)</span><br><span class="line">            </span><br><span class="line">            a=i</span><br><span class="line">            b=j</span><br><span class="line">        triminos(A,dx,mx-<span class="number">1</span>,my,fy,a,b,k+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#右上角：</span></span><br><span class="line">        a = mx</span><br><span class="line">        b = my-<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; mx-<span class="number">1</span> <span class="keyword">and</span> j &lt;my:</span><br><span class="line">            addT(A,mx-<span class="number">1</span>,my-<span class="number">1</span>,a,b,k)</span><br><span class="line">        </span><br><span class="line">            a=i</span><br><span class="line">            b=j</span><br><span class="line">        triminos(A,mx,fx,dy,my-<span class="number">1</span>,a,b,k+<span class="number">1</span>)</span><br><span class="line">        <span class="comment">#右下角：</span></span><br><span class="line">        a = mx</span><br><span class="line">        b = my</span><br><span class="line">        <span class="keyword">if</span> i &gt; mx-<span class="number">1</span> <span class="keyword">and</span> j &gt;my-<span class="number">1</span>:</span><br><span class="line">            addT(A,mx-<span class="number">1</span>,my-<span class="number">1</span>,a,b,k)</span><br><span class="line">            </span><br><span class="line">            a=i</span><br><span class="line">            b=j</span><br><span class="line">        triminos(A,mx,fx,my,fy,a,b,k+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">n=<span class="number">4</span></span><br><span class="line">N=<span class="number">2</span>**n</span><br><span class="line"><span class="comment">#从0到N-1随机取一个数</span></span><br><span class="line">x = randint(<span class="number">0</span>,N-<span class="number">1</span>)</span><br><span class="line">y = randint(<span class="number">0</span>,N-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;Le plateau fait <span class="subst">&#123;N&#125;</span>x<span class="subst">&#123;N&#125;</span> et le trou est en (<span class="subst">&#123;x&#125;</span>,<span class="subst">&#123;y&#125;</span>)&#x27;</span>)</span><br><span class="line">A = [[<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N)] <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N)] </span><br><span class="line">triminos(A, <span class="number">0</span>, N-<span class="number">1</span>, <span class="number">0</span>, N-<span class="number">1</span>, x, y, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&#x27;<span class="subst">&#123;A[i][j]:<span class="number">2</span>&#125;</span>&#x27;</span>, end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="built_in">print</span>()</span><br></pre></td></tr></table></figure>

<h4 id="4-承重算法："><a href="#4-承重算法：" class="headerlink" title="4.承重算法："></a>4.承重算法：</h4><p>从n个钱中有一个时轻的， 有一个balance，可以给出任意数量的左边还是右面轻：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#不管二分和三分，中止条件很关键，这里必须让m2=m1+1，虽然m=0也会取两个值很关键</span></span><br><span class="line"><span class="comment"># 思路是每次分成三份，比较其中的两份，如果一样重就去比第三份，否则就那这两个轻的那个去比：</span></span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compare</span>(<span class="params">A,d1,f1,d2,f2</span>):</span><br><span class="line">    a=<span class="built_in">sum</span>(A[d1:f1+<span class="number">1</span>])</span><br><span class="line">    b=<span class="built_in">sum</span>(A[d2:f2+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">if</span> a &gt; b:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> a&lt;b:</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">pese</span>(<span class="params">A,d,f</span>):</span><br><span class="line">    <span class="keyword">if</span> f == d:</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">else</span>  :</span><br><span class="line">        m = (f-d)//<span class="number">3</span></span><br><span class="line">        m1 = d + m </span><br><span class="line">        m2 = d + <span class="number">2</span>*m+<span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> compare(A,d,m1,m1+<span class="number">1</span>,m2) == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> pese(A,m2,f)</span><br><span class="line">        <span class="keyword">elif</span> compare(A,d,m1,m1+<span class="number">1</span>,m2) == -<span class="number">1</span> :</span><br><span class="line">            <span class="keyword">return</span> pese(A,d,m1)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> pese(A,m1+<span class="number">1</span>,m2)</span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">A = [<span class="number">1</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n)]</span><br><span class="line">A[randint(<span class="number">0</span>,n-<span class="number">1</span>)] = <span class="number">0</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;la fausse pièce dans <span class="subst">&#123;A&#125;</span> est à l\&#x27;indice: <span class="subst">&#123;pese(A,<span class="number">0</span>, <span class="built_in">len</span>(A)-<span class="number">1</span>)&#125;</span>&#x27;</span>)      </span><br></pre></td></tr></table></figure>



<h4 id="5-快排"><a href="#5-快排" class="headerlink" title="5.快排"></a>5.快排</h4><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p>
<p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<ol>
<li>从数列中挑出一个元素，称为 “基准”（pivot）;</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> randint,shuffle</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quicksort</span>(<span class="params">L,d,f</span>):</span><br><span class="line">    <span class="keyword">if</span> f&gt;d:</span><br><span class="line">        p=partition(L,d,f)</span><br><span class="line">        quicksort(L,d,p-<span class="number">1</span>)</span><br><span class="line">        quicksort(L,p+<span class="number">1</span>,f)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">swap</span>(<span class="params">L,i,j</span>):</span><br><span class="line">    A=L[i]</span><br><span class="line">    L[i]=L[j]</span><br><span class="line">    L[j]=A   </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">partition</span>(<span class="params">L,d,f</span>):</span><br><span class="line">    <span class="keyword">if</span> f - d == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> d</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        p=randint(d,f)</span><br><span class="line">        swap(L,p,f)</span><br><span class="line">        k=d</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(d,f):</span><br><span class="line">            <span class="keyword">if</span>  L[i] &lt; L[f]:</span><br><span class="line">                swap(L,i,k)</span><br><span class="line">                k+=<span class="number">1</span></span><br><span class="line">        swap(L,k,f)</span><br><span class="line">        <span class="keyword">return</span> k</span><br><span class="line">    </span><br><span class="line">L = <span class="built_in">list</span>(<span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line">shuffle(L)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br><span class="line">quicksort(L,<span class="number">0</span>, <span class="built_in">len</span>(L) - <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(L)</span><br></pre></td></tr></table></figure>

<p>相关计算，概率</p>
<p>![截屏2022-09-27 17.34.57](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-27 17.34.57.png)</p>
<ol>
<li>任意两对最多互相比较一次：每一次partition都是和pivot相比，且在递归中一个位置最多一次称为pivot</li>
<li>不太好用公式证明，2&#x2F;j-i+1,本质上是数树的叶节点。</li>
</ol>
<h3 id="II-V-Programmation-dynamique动态规划"><a href="#II-V-Programmation-dynamique动态规划" class="headerlink" title="II.V:Programmation dynamique动态规划"></a>II.V:Programmation dynamique动态规划</h3><p>![截屏2022-09-27 17.40.06](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-27 17.40.06.png)</p>
<p>首先可以递归解决，但是子子问题有重复，所以传统的natif的方法不行，要加上memorisation。</p>
<p>有两种思维角度：</p>
<ul>
<li><p>Approche ascendante:自下而上，用for来做，把所有需要的情况都存下来</p>
</li>
<li><p>Approche descendante:自上而下，用递归+memorisation来做</p>
</li>
</ul>
<p>状态转移+记忆</p>
<h4 id="1-probleme-du-change零钱问题："><a href="#1-probleme-du-change零钱问题：" class="headerlink" title="1.problème du change零钱问题："></a>1.problème du change零钱问题：</h4><p>用不同面额的零钱（无限数量）去凑一个数使得所需的钱最少：</p>
<p>![截屏2022-09-27 17.48.21](&#x2F;Users&#x2F;zhangxin&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;截屏2022-09-27 17.48.21.png)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>









<p>Exercice:</p>
<ol start="3">
<li></li>
</ol>
<p>P(3)&#x3D; 2</p>
<p>P(n) &#x3D; 2P(n-1)</p>
<h3 id="II-VI-Algoritme-glouton贪心算法"><a href="#II-VI-Algoritme-glouton贪心算法" class="headerlink" title="II.VI:Algoritme glouton贪心算法"></a>II.VI:Algoritme glouton贪心算法</h3><p>练习：选择</p>
<p>选择最早结束的</p>
<h1 id="III-Structures-de-donnees"><a href="#III-Structures-de-donnees" class="headerlink" title="III. Structures de données:"></a>III. Structures de données:</h1><h3 id="1-Tableaux-et-listes"><a href="#1-Tableaux-et-listes" class="headerlink" title="1.Tableaux et listes:"></a>1.Tableaux et listes:</h3><h3 id="2-Files-et-piles"><a href="#2-Files-et-piles" class="headerlink" title="2.Files et piles:"></a>2.Files et piles:</h3><h4 id="2-2-derecursification"><a href="#2-2-derecursification" class="headerlink" title="2.2 dérécursification:"></a>2.2 dérécursification:</h4><p>用frame结构体，构造pile来实现递归，熟悉pile的操作</p>
<h3 id="3-File-de-priorite-优先队列："><a href="#3-File-de-priorite-优先队列：" class="headerlink" title="3.File de priorité 优先队列："></a>3.File de priorité 优先队列：</h3><h4 id="3-1-arbre："><a href="#3-1-arbre：" class="headerlink" title="3.1 arbre："></a>3.1 arbre：</h4><h4 id="3-2-tas-binaire-二叉堆"><a href="#3-2-tas-binaire-二叉堆" class="headerlink" title="3.2 tas binaire:二叉堆"></a>3.2 tas binaire:二叉堆</h4><h4 id="3-3-tas-implicites-用数组表示二叉堆"><a href="#3-3-tas-implicites-用数组表示二叉堆" class="headerlink" title="3.3 tas implicites:用数组表示二叉堆"></a>3.3 tas implicites:用数组表示二叉堆</h4><h4 id="3-4-tri-par-tas-堆排序"><a href="#3-4-tri-par-tas-堆排序" class="headerlink" title="3.4 tri par tas:堆排序"></a>3.4 tri par tas:堆排序</h4><h3 id="4-ensemble-et-tableau-associatif集合和关联数组：（集合、多重集、关联数组）"><a href="#4-ensemble-et-tableau-associatif集合和关联数组：（集合、多重集、关联数组）" class="headerlink" title="4. ensemble et tableau associatif集合和关联数组：（集合、多重集、关联数组）"></a>4. ensemble et tableau associatif集合和关联数组：（<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9B%86%E5%90%88_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">集合</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%9A%E9%87%8D%E9%9B%86">多重集</a>、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84">关联数组</a>）</h3><h4 id="4-1-ABR-二叉搜索树：-二叉搜索树的插入，删除"><a href="#4-1-ABR-二叉搜索树：-二叉搜索树的插入，删除" class="headerlink" title="4.1 ABR 二叉搜索树： 二叉搜索树的插入，删除"></a>4.1 ABR 二叉搜索树： 二叉搜索树的插入，删除</h4><h4 id="4-2-arbre-equilibre-树的平衡-自平衡树"><a href="#4-2-arbre-equilibre-树的平衡-自平衡树" class="headerlink" title="4.2 arbre équilibré 树的平衡: 自平衡树"></a>4.2 arbre équilibré 树的平衡: 自平衡树</h4><ul>
<li>arbre AVL:<strong>AVL树</strong>（Adelson-Velsky and Landis Tree）是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6">计算机科学</a>中最早被发明的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91">自平衡二叉查找树</a>。在AVL树中，任一节点对应的两棵子树的最大高度差为1，因此它也被称为<strong>高度平衡树</strong>。增加和删除元素的操作则可能需要借由一次或多次<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%91%E6%97%8B%E8%BD%AC">树旋转</a>，以实现树的重新平衡。</li>
</ul>
<h4 id="4-3-散列表-哈希表："><a href="#4-3-散列表-哈希表：" class="headerlink" title="4.3 散列表-哈希表："></a>4.3 散列表-哈希表：</h4><p>Facteur déquilibre平衡因子</p>
<p>用list trié实现集合的交集并集差集操作：</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>Invariance (sort):après la ke itération , les k+1 premiers cases de T sont par ordre croissant   哪一种放进去不会变，就是要实现的效果, 就是在第k次循环后，循环内部各种值的变化，整体的变化以及退出条件。</p>
<p>au ke appel de insert: </p>
<ul>
<li>Précondition:</li>
</ul>
<p>​       les k premiers triés</p>
<ul>
<li><p>Postcondition:</p>
<p>les k+1 premiers triés</p>
</li>
</ul>
<p>Invariance while:  après la ke itération,</p>
<ol>
<li><p>j&#x3D;x-1-m, </p>
</li>
<li><p>les m éléments d’indice plus grand que j sont &gt; key</p>
</li>
<li><p>Soit A[j]&gt;key, soit(A[j]&lt;&#x3D;key, et pour tout i &lt;&#x3D;j, A[j]&lt;&#x3D;key)</p>
</li>
<li><p>soit A’ la valeur de A au début de while :</p>
<p>Si x&gt; i&gt;j,A[i+1]&#x3D;A’[i]</p>
<p>Si i&lt;&#x3D;j,A[i]&#x3D;A’[i]</p>
</li>
</ol>
<h2 id="algorithmique-d’Euclide"><a href="#algorithmique-d’Euclide" class="headerlink" title="algorithmique d’Euclide:"></a>algorithmique d’Euclide:</h2><p>Invariance :après la i itération</p>
<ol>
<li>pgcd(ai,bi)&#x3D;pgcd(a0,b0) correction de l’algoritme 从原理上值的变化</li>
<li>0&lt;ai&lt;ai-1 ou 0&lt;bi&lt;bi-1  la termination 系数上是否有relation满足bien fondé</li>
</ol>
<p>invariance while for 和recursif</p>
<h2 id="invariants-pour-les-programmes-recursifs"><a href="#invariants-pour-les-programmes-recursifs" class="headerlink" title="invariants pour les programmes récursifs:"></a>invariants pour les programmes récursifs:</h2><p>la fonction se termine parsque elle forme une suite strictement décroissante pour l’ensemble bien fondé.</p>
<h2 id="Invariants-et-probleme-insolubles"><a href="#Invariants-et-probleme-insolubles" class="headerlink" title="Invariants et problème insolubles"></a>Invariants et problème insolubles</h2><ol>
<li>le nombre des cases est toujours pair</li>
<li>les nombres des cases noirs et cases blanches sont égaux.</li>
</ol>
<h2 id="Preuve-automatique-et-indecidabilite"><a href="#Preuve-automatique-et-indecidabilite" class="headerlink" title="Preuve automatique et indécidabilité"></a>Preuve automatique et indécidabilité</h2><p>举了几个例子感兴趣回去查一下</p>
<h2 id="exercice-Machine-Turing"><a href="#exercice-Machine-Turing" class="headerlink" title="exercice: Machine Turing"></a>exercice: Machine Turing</h2><h2 id="Probleme-de-SAT"><a href="#Probleme-de-SAT" class="headerlink" title="Problème de SAT"></a>Problème de SAT</h2><h2 id="Machine-de-Turing-Non-deterministe"><a href="#Machine-de-Turing-Non-deterministe" class="headerlink" title="Machine de Turing Non déterministe:"></a>Machine de Turing Non déterministe:</h2><h2 id="ILP-NP"><a href="#ILP-NP" class="headerlink" title="ILP-NP"></a>ILP-NP</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="http://example.com">Xin Zhang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://example.com/2022/10/16/algoa-cm/">http://example.com/2022/10/16/algoa-cm/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">著作权归作者所有。商业转载请联络作者获得授权，非商业转载请标明出处</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ECN/">ECN</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a><a class="post-meta__tags" href="/tags/ALGOA/">ALGOA</a><a class="post-meta__tags" href="/tags/PYTHON/">PYTHON</a><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="/img/ECN.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/10/16/algoa-tp1/"><img class="prev-cover" src="/img/ECN.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">ALGOA-TP1</div></div></a></div><div class="next-post pull-right"><a href="/2022/10/16/conda/"><img class="next-cover" src="/img/ECN.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">conda</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/2022/10/16/algoa-tp1/" title="ALGOA-TP1"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">ALGOA-TP1</div></div></a></div><div><a href="/2022/10/16/PAPY_C5_%E6%96%87%E4%BB%B6%E6%96%87%E6%A1%A3/" title="PAPY-CM6"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PAPY-CM6</div></div></a></div><div><a href="/2022/10/16/PAPY_C3_modules_numpy/" title="PAPY-CM2"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PAPY-CM2</div></div></a></div><div><a href="/2022/10/16/PAPY_TP1/" title="PAPY-TP1"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PAPY-TP1</div></div></a></div><div><a href="/2022/10/16/PAPY_TP3.2-%E8%88%AA%E7%BA%BFpandas/" title="PAPY-TP3"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PAPY-TP3</div></div></a></div><div><a href="/2022/10/16/PAPY%E8%87%AA%E5%AD%A6/" title="PAPY-自学"><img class="cover" src="/img/ECN.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-16</div><div class="title">PAPY-自学</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Xin Zhang</div><div class="author-info__description">被教育行业咸鱼</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/XinZhang0423"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/XinZhang0423" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:zxin0423@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">转码日记-从入门到菜鸡全记录</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#I-Analyse-d%E2%80%99algorithmes-%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%E5%AD%A6"><span class="toc-number">1.</span> <span class="toc-text">I. Analyse d’algorithmes: 算法分析学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#I-I-Prouver-des-proprietes-%E8%AF%81%E6%98%8E%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">I.I Prouver des propriétés: 证明算法的性质</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Proprietes-non-fonctionnelles-%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.Propriétés non-fonctionnelles:非功能性性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Proprietes-fonctionnelles-%E5%8A%9F%E8%83%BD%E6%80%A7%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.2.</span> <span class="toc-text">2.Propriétés fonctionnelles: 功能性性质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PF-Exercice-1-correction-fonctionnelle-du-tri-par-insertion-%E4%BB%A5%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BE%8B%EF%BC%8C%E7%A0%94%E7%A9%B6%E7%AE%97%E6%B3%95%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7%E8%B4%A8"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">PF_Exercice 1 : correction fonctionnelle du tri par insertion 以插值算法为例，研究算法的功能性质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PF-Exercice-2-algorithme-d%E2%80%99Euclide-%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%97%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">PF_Exercice 2 : algorithme d’Euclide 欧几里得算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-Performances"><span class="toc-number">1.1.3.</span> <span class="toc-text">3.Performances:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-Invariant-et-probleme-insoluble%EF%BC%9A%EF%BC%88%E6%B2%A1%E6%9C%89%E7%AE%97%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%9D%A5%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. Invariant et problème insoluble：（没有算法可以来解决的问题）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Insoluble-Exercice%EF%BC%9Adominos%E8%A6%86%E7%9B%96%E6%A3%8B%E7%9B%98%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">Insoluble_Exercice：dominos覆盖棋盘问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-Preuve-automatique-et-indecidabilite-%E5%86%B3%E5%AE%9A%E6%80%A7%E9%97%AE%E9%A2%98-sat%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.5.</span> <span class="toc-text">5. Preuve automatique et indécidabilité: 决定性问题 sat问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#I-II-Complexite-%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.2.</span> <span class="toc-text">I.II Complexité:复杂度：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Machine-de-Turing-%E5%9B%BE%E7%81%B5%E6%9C%BA%EF%BC%9A"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.Machine de Turing 图灵机：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1%E4%BC%A0%E7%BB%9F%E5%9B%BE%E7%81%B5%E6%9C%BAmachine-de-turing-determinate"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">1.1传统图灵机machine de turing determinate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MT-Exemple-%E8%AE%A1%E7%AE%97%E8%A1%A5%E7%A0%81%EF%BC%9A"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">MT_Exemple:计算补码：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MT-Exercice-%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E8%AF%8D%E6%98%AF%E4%B8%8D%E6%98%AFpalindrome%E5%9B%9E%E6%96%87"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">MT_Exercice:判断一个词是不是palindrome回文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-machine-de-turing-non-determiste"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">1.2 machine de turing non-determiste:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#MTND-Exercice-%E8%AF%81%E6%98%8Eilp%E6%98%AFnp%E5%AE%8C%E5%85%A8%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">1.2.1.5.</span> <span class="toc-text">MTND_Exercice:证明ilp是np完全问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-ram%EF%BC%9A"><span class="toc-number">1.2.2.</span> <span class="toc-text">2. ram：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-complexite-asymptotique%EF%BC%9A%E5%BD%93%E8%BE%93%E5%85%A5%E7%9A%84n%E8%B6%8B%E4%BA%8E%E6%97%A0%E7%A9%B7%E6%97%B6%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6%E3%80%82%E6%B8%90%E8%BF%9B%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.3.</span> <span class="toc-text">3.complexite asymptotique：当输入的n趋于无穷时的复杂度。渐进复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#CPC-Exercice1-%E8%AE%A1%E7%AE%97%E5%90%84%E7%A7%8D%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84nombre-d%E2%80%99inversion%EF%BC%9A"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">CPC_Exercice1:计算各种复杂度的nombre d’inversion：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-Complexite-pire-cas-des-algorithmes-recursifs"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">4. Complexité pire cas des algorithmes récursifs :</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CPC-Exercice2-%E8%AF%81%E6%98%8E%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">CPC_Exercice2:证明斐波那契数列复杂度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-complexite-moyenne%E5%B9%B3%E5%9D%87%E5%A4%8D%E6%9D%82%E5%BA%A6%EF%BC%9A"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">5.complexité moyenne平均复杂度：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CP-Exercice1"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">CP_Exercice1:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CP-Exercice2"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">CP_Exercice2:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CP-Exercice3"><span class="toc-number">1.2.3.7.</span> <span class="toc-text">CP_Exercice3:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-algoritme-probabiliste-%E5%9C%A8%E6%89%A7%E8%A1%8C%E4%BC%A0%E7%BB%9F%E7%AE%97%E6%B3%95%E5%89%8D%E9%9A%8F%E6%9C%BA%E6%B7%B7%E5%90%88%E8%BE%93%E5%85%A5%E3%80%82"><span class="toc-number">1.2.4.</span> <span class="toc-text">6. algoritme probabiliste: 在执行传统算法前随机混合输入。</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Exemple-Monte-Carlo-Las-Vegas"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">Exemple:Monte-Carlo,Las Vegas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Algo-Exercice1-l%E5%88%A9%E7%94%A8biais-random%E6%9E%84%E9%80%A0%E4%BC%AF%E5%8A%AA%E5%88%A9%E5%88%86%E5%B8%83%EF%BC%8C%E4%B9%9F%E6%98%AF%E6%9E%84%E9%80%A0%E6%8C%87%E7%A4%BA%E6%80%A7%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E6%9D%A5%E6%B1%82%EF%BC%8C%E5%B9%B3%E5%9D%87%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E6%B1%82%E6%A6%82%E7%8E%87%E6%80%A7%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E9%83%BD%E6%98%AF%E5%A6%82%E6%AD%A4%E3%80%82%E5%9B%A0%E4%B8%BA%E6%9C%AC%E8%BA%AB%E5%B9%B3%E5%9D%87%E5%A4%8D%E6%9D%82%E7%9A%84%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%88%E9%9C%80%E8%A6%81%E7%90%86%E8%A7%A3%E4%B8%80%E4%B8%8B%EF%BC%9F%EF%BC%89"><span class="toc-number">1.2.4.2.</span> <span class="toc-text">Algo_Exercice1:l利用biais_random构造伯努利分布，也是构造指示性随机变量来求，平均复杂度和求概率性算法复杂度都是如此。因为本身平均复杂的的概念（需要理解一下？）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Algo-Exercice2-%E5%88%A9%E7%94%A8%E9%80%92%E5%BD%92%E8%AF%81%E6%98%8E%E6%8E%92%E5%BA%8F%EF%BC%8C%E5%B9%B6%E6%B1%82%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.2.4.3.</span> <span class="toc-text">Algo_Exercice2:利用递归证明排序，并求复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#II-Conception-d%E2%80%99algorithmes-%E5%87%A0%E5%A4%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">II. Conception d’algorithmes:几大算法设计理念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#II-I-Enumeration-exhaustive%E7%A9%B7%E4%B8%BE%E6%B3%95"><span class="toc-number">2.0.1.</span> <span class="toc-text">II.I Énumération exhaustive穷举法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-carre-magique"><span class="toc-number">2.0.1.1.</span> <span class="toc-text">1.carré magique:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E5%90%8E%E7%BB%83%E4%B9%A0%EF%BC%9A%E7%94%A8%E6%9E%9A%E4%B8%BE%E6%B3%95%E5%86%99%E5%85%AB%E7%9A%87%E5%90%8E%E9%97%AE%E9%A2%98%EF%BC%8Csat%E9%97%AE%E9%A2%98%E7%AD%89%E7%AD%89"><span class="toc-number">2.1.</span> <span class="toc-text">课后练习：用枚举法写八皇后问题，sat问题等等</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#II-II-Backtracking%E5%9B%9E%E6%BA%AF%E6%B3%95"><span class="toc-number">2.1.1.</span> <span class="toc-text">II.II :Backtracking回溯法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-IV-Diviser-pour-regner%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">2.1.2.</span> <span class="toc-text">II.IV:Diviser pour régner分治法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%90%86%E8%A7%A3%E5%88%86%E6%B2%BB%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%EF%BC%9A"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">1.归并排序理解分治法——二路归并：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-recherche-dichotomique%EF%BC%9A"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">2. 二分查找 recherche dichotomique：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%9C%A8%E6%9C%89%E6%B4%9E%E7%9A%84%E6%A3%8B%E7%9B%98%E4%B8%8A%E9%93%BA%E7%89%8Cpavage-de-trominos"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">3. 在有洞的棋盘上铺牌pavage de trominos</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%BF%E9%87%8D%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">4.承重算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%BF%AB%E6%8E%92"><span class="toc-number">2.1.2.5.</span> <span class="toc-text">5.快排</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-V-Programmation-dynamique%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">2.1.3.</span> <span class="toc-text">II.V:Programmation dynamique动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-probleme-du-change%E9%9B%B6%E9%92%B1%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">2.1.3.1.</span> <span class="toc-text">1.problème du change零钱问题：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#II-VI-Algoritme-glouton%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.4.</span> <span class="toc-text">II.VI:Algoritme glouton贪心算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#III-Structures-de-donnees"><span class="toc-number">3.</span> <span class="toc-text">III. Structures de données:</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Tableaux-et-listes"><span class="toc-number">3.0.1.</span> <span class="toc-text">1.Tableaux et listes:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-Files-et-piles"><span class="toc-number">3.0.2.</span> <span class="toc-text">2.Files et piles:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-derecursification"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">2.2 dérécursification:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-File-de-priorite-%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%EF%BC%9A"><span class="toc-number">3.0.3.</span> <span class="toc-text">3.File de priorité 优先队列：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-arbre%EF%BC%9A"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">3.1 arbre：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-tas-binaire-%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">3.2 tas binaire:二叉堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-tas-implicites-%E7%94%A8%E6%95%B0%E7%BB%84%E8%A1%A8%E7%A4%BA%E4%BA%8C%E5%8F%89%E5%A0%86"><span class="toc-number">3.0.3.3.</span> <span class="toc-text">3.3 tas implicites:用数组表示二叉堆</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-tri-par-tas-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">3.0.3.4.</span> <span class="toc-text">3.4 tri par tas:堆排序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ensemble-et-tableau-associatif%E9%9B%86%E5%90%88%E5%92%8C%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%EF%BC%9A%EF%BC%88%E9%9B%86%E5%90%88%E3%80%81%E5%A4%9A%E9%87%8D%E9%9B%86%E3%80%81%E5%85%B3%E8%81%94%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">3.0.4.</span> <span class="toc-text">4. ensemble et tableau associatif集合和关联数组：（集合、多重集、关联数组）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-ABR-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%9A-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5%EF%BC%8C%E5%88%A0%E9%99%A4"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">4.1 ABR 二叉搜索树： 二叉搜索树的插入，删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-arbre-equilibre-%E6%A0%91%E7%9A%84%E5%B9%B3%E8%A1%A1-%E8%87%AA%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">4.2 arbre équilibré 树的平衡: 自平衡树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%95%A3%E5%88%97%E8%A1%A8-%E5%93%88%E5%B8%8C%E8%A1%A8%EF%BC%9A"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">4.3 散列表-哈希表：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">3.1.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#algorithmique-d%E2%80%99Euclide"><span class="toc-number">3.2.</span> <span class="toc-text">algorithmique d’Euclide:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#invariants-pour-les-programmes-recursifs"><span class="toc-number">3.3.</span> <span class="toc-text">invariants pour les programmes récursifs:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Invariants-et-probleme-insolubles"><span class="toc-number">3.4.</span> <span class="toc-text">Invariants et problème insolubles</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Preuve-automatique-et-indecidabilite"><span class="toc-number">3.5.</span> <span class="toc-text">Preuve automatique et indécidabilité</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exercice-Machine-Turing"><span class="toc-number">3.6.</span> <span class="toc-text">exercice: Machine Turing</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Probleme-de-SAT"><span class="toc-number">3.7.</span> <span class="toc-text">Problème de SAT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Machine-de-Turing-Non-deterministe"><span class="toc-number">3.8.</span> <span class="toc-text">Machine de Turing Non déterministe:</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ILP-NP"><span class="toc-number">3.9.</span> <span class="toc-text">ILP-NP</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/10/20/PAPY_TP1_%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2022/10/20/PAPY_TP1_%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="No title">No title</a><time datetime="2022-10-20T12:58:38.092Z" title="Created 2022-10-20 14:58:38">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/20/PAPY_TP2.1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2022/10/20/PAPY_TP2.1_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB/" title="No title">No title</a><time datetime="2022-10-20T12:58:29.206Z" title="Created 2022-10-20 14:58:29">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/20/PAPY_TP3.1-nump%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2022/10/20/PAPY_TP3.1-nump%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/" title="No title">No title</a><time datetime="2022-10-20T12:58:08.000Z" title="Created 2022-10-20 14:58:08">2022-10-20</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/18/%E9%9D%A2%E8%AF%95/" title="No title"><img src="https://i.loli.net/2020/05/01/gkihqEjXxJ5UZ1C.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="No title"/></a><div class="content"><a class="title" href="/2022/10/18/%E9%9D%A2%E8%AF%95/" title="No title">No title</a><time datetime="2022-10-18T13:13:32.973Z" title="Created 2022-10-18 15:13:32">2022-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/16/PAPY_C5_%E6%96%87%E4%BB%B6%E6%96%87%E6%A1%A3/" title="PAPY-CM6"><img src="/img/ECN.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PAPY-CM6"/></a><div class="content"><a class="title" href="/2022/10/16/PAPY_C5_%E6%96%87%E4%BB%B6%E6%96%87%E6%A1%A3/" title="PAPY-CM6">PAPY-CM6</a><time datetime="2022-10-16T20:52:06.000Z" title="Created 2022-10-16 22:52:06">2022-10-16</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Switch Between Traditional Chinese And Simplified Chinese">繁</button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>